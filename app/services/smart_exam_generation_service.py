"""
Service cho vi·ªác t·∫°o ƒë·ªÅ thi th√¥ng minh theo chu·∫©n THPT 2025
"""

import logging
import json
import asyncio
from typing import Dict, Any, List, Optional
from datetime import datetime

from app.models.smart_exam_models import SmartExamRequest, ExamStatistics
from app.services.openrouter_service import get_openrouter_service
from app.core.config import settings

logger = logging.getLogger(__name__)


class SmartExamGenerationService:
    """Service t·∫°o ƒë·ªÅ thi th√¥ng minh theo chu·∫©n THPT 2025"""

    def __init__(self):
        self.llm_service = get_openrouter_service()
        # ƒê·∫£m b·∫£o service ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë·∫ßy ƒë·ªß
        self.llm_service._ensure_service_initialized()
        logger.info("üîÑ SmartExamGenerationService: First-time initialization triggered")

    async def generate_smart_exam(
        self, exam_request: SmartExamRequest, lesson_content: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        T·∫°o ƒë·ªÅ thi th√¥ng minh theo chu·∫©n THPT 2025

        Args:
            exam_request: Request ch·ª©a ma tr·∫≠n ƒë·ªÅ thi
            lesson_content: N·ªôi dung b√†i h·ªçc t·ª´ Qdrant

        Returns:
            Dict ch·ª©a ƒë·ªÅ thi ƒë√£ ƒë∆∞·ª£c t·∫°o
        """
        try:
            start_time = datetime.now()

            # Ensure LLM service is initialized
            self.llm_service._ensure_service_initialized()

            if not self.llm_service.is_available():
                return {
                    "success": False,
                    "error": "LLM service not available. Please check OpenRouter API configuration."
                }

            # T·∫°o c√¢u h·ªèi cho t·ª´ng ph·∫ßn theo chu·∫©n THPT 2025
            all_questions = []
            part_statistics = {"part_1": 0, "part_2": 0, "part_3": 0}
            for lesson_matrix in exam_request.matrix:
                lesson_questions = await self._generate_questions_for_lesson(
                    lesson_matrix, lesson_content, exam_request.subject
                )
                
                # Ph√¢n lo·∫°i c√¢u h·ªèi theo ph·∫ßn
                for question in lesson_questions:
                    part_num = question.get("part", 1)
                    part_statistics[f"part_{part_num}"] += 1
                
                all_questions.extend(lesson_questions)

            # S·∫Øp x·∫øp c√¢u h·ªèi theo ph·∫ßn v√† ƒë√°nh s·ªë l·∫°i
            sorted_questions = self._sort_and_renumber_questions(all_questions)

            # T√≠nh to√°n th·ªëng k√™
            end_time = datetime.now()
            generation_time = (end_time - start_time).total_seconds()
            
            statistics = self._calculate_statistics(
                sorted_questions, exam_request, generation_time
            )

            return {
                "success": True,
                "exam_id": f"smart_exam_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                "questions": sorted_questions,
                "statistics": statistics,
                "total_generated": len(sorted_questions),
                "exam_request": exam_request.model_dump()
            }

        except Exception as e:
            logger.error(f"Error generating smart exam: {e}")
            return {
                "success": False,
                "error": f"Failed to generate smart exam: {str(e)}"
            }

    async def _generate_questions_for_lesson(
        self, lesson_matrix, lesson_content: Dict[str, Any], subject: str
    ) -> List[Dict[str, Any]]:
        """T·∫°o c√¢u h·ªèi cho m·ªôt b√†i h·ªçc theo ma tr·∫≠n"""
        try:
            lesson_id = lesson_matrix.lessonId

            # L·∫•y n·ªôi dung b√†i h·ªçc t·ª´ textbook_retrieval_service format
            lesson_data = lesson_content.get(lesson_id, {})

            if not lesson_data:
                error_msg = f"Kh√¥ng t√¨m th·∫•y n·ªôi dung cho b√†i h·ªçc {lesson_id} trong lesson_content"
                logger.error(error_msg)
                raise ValueError(error_msg)

            # Ki·ªÉm tra xem lesson_data c√≥ lesson_content kh√¥ng (t·ª´ textbook_retrieval_service)
            if not lesson_data.get("lesson_content"):
                error_msg = f"Lesson {lesson_id} kh√¥ng c√≥ n·ªôi dung lesson_content. Available keys: {list(lesson_data.keys())}"
                logger.error(error_msg)
                raise ValueError(error_msg)

            all_lesson_questions = []

            # T·∫°o c√¢u h·ªèi cho t·ª´ng ph·∫ßn - truy·ªÅn lesson_data thay v√¨ actual_content
            for part in lesson_matrix.parts:
                # Debug logging
                total_expected = part.objectives.Bi·∫øt + part.objectives.Hi·ªÉu + part.objectives.V·∫≠n_d·ª•ng
                logger.info(f"[DEBUG] Processing Part {part.part}: Expected {total_expected} questions (Bi·∫øt:{part.objectives.Bi·∫øt}, Hi·ªÉu:{part.objectives.Hi·ªÉu}, V·∫≠n_d·ª•ng:{part.objectives.V·∫≠n_d·ª•ng})")

                part_questions = await self._generate_questions_for_part(
                    part, lesson_data, subject, lesson_id
                )

                logger.info(f"[DEBUG] Part {part.part} generated {len(part_questions)} questions")
                all_lesson_questions.extend(part_questions)

            return all_lesson_questions

        except Exception as e:
            logger.error(f"Error generating questions for lesson {lesson_matrix.lessonId}: {e}")
            return []

    async def _generate_questions_for_part(
        self, part, lesson_data: Dict[str, Any], subject: str, lesson_id: str
    ) -> List[Dict[str, Any]]:
        """T·∫°o c√¢u h·ªèi cho m·ªôt ph·∫ßn c·ª• th·ªÉ"""
        try:
            part_questions = []
            part_num = part.part
            objectives = part.objectives

            # T·∫°o c√¢u h·ªèi theo ma tr·∫≠n ƒëa d·∫°ng THPT 2025 - h·ªó tr·ª£ t·∫•t c·∫£ m·ª©c ƒë·ªô cho Ph·∫ßn 1 v√† 2
            if part_num == 1:
                # Ph·∫ßn I: Tr·∫Øc nghi·ªám nhi·ªÅu l·ª±a ch·ªçn - h·ªó tr·ª£ Bi·∫øt, Hi·ªÉu, V·∫≠n d·ª•ng
                for level, count in [("Bi·∫øt", objectives.Bi·∫øt), ("Hi·ªÉu", objectives.Hi·ªÉu), ("V·∫≠n_d·ª•ng", objectives.V·∫≠n_d·ª•ng)]:
                    if count > 0:
                        level_questions = await self._generate_questions_for_level(
                            part_num, level, count, lesson_data, subject, lesson_id
                        )
                        part_questions.extend(level_questions)
            elif part_num == 2:
                # Ph·∫ßn II: Tr·∫Øc nghi·ªám ƒê√∫ng/Sai - h·ªó tr·ª£ Bi·∫øt, Hi·ªÉu, V·∫≠n d·ª•ng
                for level, count in [("Bi·∫øt", objectives.Bi·∫øt), ("Hi·ªÉu", objectives.Hi·ªÉu), ("V·∫≠n_d·ª•ng", objectives.V·∫≠n_d·ª•ng)]:
                    if count > 0:
                        level_questions = await self._generate_questions_for_level(
                            part_num, level, count, lesson_data, subject, lesson_id
                        )
                        part_questions.extend(level_questions)
            elif part_num == 3:
                # Ph·∫ßn III: T·ª± lu·∫≠n t√≠nh to√°n - h·ªó tr·ª£ Bi·∫øt, Hi·ªÉu, V·∫≠n d·ª•ng
                for level, count in [("Bi·∫øt", objectives.Bi·∫øt), ("Hi·ªÉu", objectives.Hi·ªÉu), ("V·∫≠n_d·ª•ng", objectives.V·∫≠n_d·ª•ng)]:
                    if count > 0:
                        level_questions = await self._generate_questions_for_level(
                            part_num, level, count, lesson_data, subject, lesson_id
                        )
                        part_questions.extend(level_questions)

            return part_questions

        except Exception as e:
            logger.error(f"Error generating questions for part {part.part}: {e}")
            return []

    async def _generate_questions_for_level(
        self, part_num: int, level: str, count: int, lesson_data: Dict[str, Any],
        subject: str, lesson_id: str
    ) -> List[Dict[str, Any]]:
        """T·∫°o c√¢u h·ªèi cho m·ªôt m·ª©c ƒë·ªô nh·∫≠n th·ª©c c·ª• th·ªÉ"""
        try:
            # T·∫°o prompt cho LLM
            prompt = self._create_prompt_for_level(
                part_num, level, count, lesson_data, subject, lesson_id
            )   
            print(f"Generated prompt: {prompt}")

            # G·ªçi LLM ƒë·ªÉ t·∫°o c√¢u h·ªèi - tƒÉng max_tokens cho nhi·ªÅu c√¢u h·ªèi
            max_tokens = 6000 if count > 3 else 4000  # TƒÉng token limit cho nhi·ªÅu c√¢u
            response = await self.llm_service.generate_content(
                prompt=prompt,
                temperature=0.3,
                max_tokens=max_tokens
            )
            print(f"LLM response: {response}")
            if not response.get("success", False):
                logger.error(f"LLM failed for part {part_num}, level {level}: {response.get('error')}")
                return []

            # Parse response JSON
            questions = self._parse_llm_response(response.get("text", ""), part_num, level, lesson_id)
            print(f"Parsed questions: {questions}")

            # Debug logging
            logger.info(f"[DEBUG] Part {part_num}, Level {level}: Requested {count} questions, LLM generated {len(questions)} questions")

            # Gi·ªõi h·∫°n s·ªë c√¢u h·ªèi theo y√™u c·∫ßu
            limited_questions = questions[:count]
            logger.info(f"[DEBUG] Part {part_num}, Level {level}: Returning {len(limited_questions)} questions after limit")

            return limited_questions

        except Exception as e:
            logger.error(f"Error generating questions for level {level}: {e}")
            return []



    def _create_prompt_for_level(
        self, part_num: int, level: str, count: int,
        lesson_data: Dict[str, Any], subject: str, lesson_id: str
    ) -> str:
        """Create prompt for LLM according to THPT 2025 standards"""

        # L·∫•y n·ªôi dung b√†i h·ªçc t·ª´ textbook_retrieval_service format
        main_content = ""
        lesson_info = {}

        if "lesson_content" in lesson_data:
            # T·ª´ textbook_retrieval_service
            main_content = lesson_data.get("lesson_content", "")
            lesson_info = {
                "lesson_id": lesson_data.get("lesson_id", lesson_id),
                "book_id": lesson_data.get("book_id", ""),
                "collection_name": lesson_data.get("collection_name", ""),
                "total_chunks": lesson_data.get("total_chunks", 0)
            }
        else:
            # Fallback cho format c≈©
            main_content = lesson_data.get("main_content", "")
            lesson_info = lesson_data.get("lesson_info", {})

        # Ensure main_content is string and limit length
        if isinstance(main_content, str):
            content_preview = main_content[:2000] if len(main_content) > 2000 else main_content
        elif isinstance(main_content, list):
            # If it's a list, join the items
            content_preview = " ".join(str(item) for item in main_content)[:2000]
        else:
            content_preview = str(main_content)[:2000] if main_content else ""

        if not content_preview.strip():
            # B√°o l·ªói thay v√¨ s·ª≠ d·ª•ng fallback theo y√™u c·∫ßu
            error_msg = f"Kh√¥ng t√¨m th·∫•y n·ªôi dung cho b√†i h·ªçc {lesson_id}. Lesson data keys: {list(lesson_data.keys())}"
            logger.error(error_msg)
            raise ValueError(error_msg)

        # Part descriptions theo chu·∫©n THPT 2025 - ƒëa d·∫°ng m·ª©c ƒë·ªô
        part_descriptions = {
            1: "PART I: Tr·∫Øc nghi·ªám nhi·ªÅu l·ª±a ch·ªçn (A, B, C, D) - H·ªó tr·ª£ m·ª©c ƒë·ªô BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG: 18 c√¢u ƒëa d·∫°ng t·ª´ nh·∫≠n bi·∫øt ƒë·∫øn t√≠nh to√°n ƒë∆°n gi·∫£n",
            2: "PART II: Tr·∫Øc nghi·ªám ƒê√∫ng/Sai - H·ªó tr·ª£ m·ª©c ƒë·ªô BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG: 4 c√¢u l·ªõn, m·ªói c√¢u c√≥ 4 ph√°t bi·ªÉu a,b,c,d ƒë·ªÉ ƒë√°nh gi√°",
            3: "PART III: T·ª± lu·∫≠n t√≠nh to√°n - H·ªó tr·ª£ m·ª©c ƒë·ªô BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG: B√†i to√°n t√≠nh to√°n t·ª´ c∆° b·∫£n ƒë·∫øn ph·ª©c t·∫°p, ƒë√≤i h·ªèi t∆∞ duy v√† t·ªïng h·ª£p ki·∫øn th·ª©c"
        }

        prompt = f"""
B·∫°n l√† chuy√™n gia t·∫°o ƒë·ªÅ thi {subject} theo chu·∫©n THPT 2025, h√£y d·ª±a v√†o th√¥ng tin cung c·∫•p b√™n d∆∞·ªõi ƒë·ªÉ t·∫°o ra ma tr·∫≠n ƒë·ªÅ v√† tr·∫£ v·ªÅ JSON t∆∞∆°ng ·ª©ng
{part_descriptions.get(part_num, "")}
TH√îNG TIN B√ÄI H·ªåC:
- N·ªôi dung: {content_preview}...

Y√äU C·∫¶U:
- T·∫°o {count} c√¢u h·ªèi ·ªü m·ª©c ƒë·ªô nh·∫≠n th·ª©c "{level}"
- Ph·∫ßn {part_num} - {self._get_part_description(part_num)}
- C√¢u h·ªèi ph·∫£i d·ª±a tr√™n n·ªôi dung b√†i h·ªçc
- Ng·ªØ li·ªáu, d·ªØ ki·ªán trong c√¢u ph·∫£i khoa h·ªçc, ƒë√∫ng th·ª±c t·∫ø.
- Tu√¢n th·ªß nghi√™m ng·∫∑t ma tr·∫≠n ƒë·ªÅ thi chu·∫©n THPT 2025
- ƒê·∫£m b·∫£o ki·∫øn th·ª©c ch√≠nh x√°c, logic, kh√¥ng g√¢y hi·ªÉu nh·∫ßm.
{self._get_specific_instructions_by_part(part_num, level)}

ƒê·ªäNH D·∫†NG JSON TR·∫¢ V·ªÄ:
[
    {{
        "question": "N·ªôi dung c√¢u h·ªèi",
        "answer": {self._get_answer_format_by_part(part_num)},
        "explanation": "Gi·∫£i th√≠ch ƒë√°p √°n",
        "cognitive_level": "{level}",
        "part": {part_num}
    }}
]

L∆∞u √Ω: ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng c√≥ vƒÉn b·∫£n b·ªï sung.
"""
        return prompt

    def _get_part_description(self, part_num: int) -> str:
        """Get detailed description for each part theo chu·∫©n THPT 2025"""
        descriptions = {
            1: "Tr·∫Øc nghi·ªám nhi·ªÅu ph∆∞∆°ng √°n (H·ªó tr·ª£ BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG)",
            2: "Tr·∫Øc nghi·ªám ƒë√∫ng/sai (H·ªó tr·ª£ BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG)",
            3: "T·ª± lu·∫≠n t√≠nh to√°n (H·ªó tr·ª£ BI·∫æT, HI·ªÇU, V·∫¨N D·ª§NG)"
        }
        return descriptions.get(part_num, "")

    def _get_specific_instructions_by_part(self, part_num: int, level: str) -> str:
        """H∆∞·ªõng d·∫´n c·ª• th·ªÉ cho t·ª´ng ph·∫ßn theo chu·∫©n THPT 2025"""
        if part_num == 1:
            if level == "Bi·∫øt":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N I - M·ª®C ƒê·ªò BI·∫æT:
- M·ªói c√¢u c√≥ 4 ph∆∞∆°ng √°n A, B, C, D v·ªõi ch·ªâ 1 ƒë√°p √°n ƒë√∫ng
- Ki·ªÉm tra ki·∫øn th·ª©c l√Ω thuy·∫øt n·ªÅn t·∫£ng v√† kh·∫£ nƒÉng nh·∫≠n bi·∫øt c√°c kh√°i ni·ªám c∆° b·∫£n
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: Nh·∫≠n bi·∫øt kh√°i ni·ªám, ƒë·ªãnh nghƒ©a, t√≠nh ch·∫•t
- Nh·∫≠n bi·∫øt c√¥ng th·ª©c h√≥a h·ªçc, t√™n g·ªçi h·ª£p ch·∫•t
- Ph√¢n lo·∫°i ch·∫•t (axit, baz∆°, mu·ªëi, oxit)
- Nh·∫≠n bi·∫øt t√≠nh ch·∫•t v·∫≠t l√Ω, h√≥a h·ªçc c∆° b·∫£n
- V√≠ d·ª•: "Ch·∫•t n√†o sau ƒë√¢y l√† axit m·∫°nh?" ho·∫∑c "C√¥ng th·ª©c ph√¢n t·ª≠ c·ªßa glucose l√†?"

D·∫†NG 2: Nh·∫≠n bi·∫øt ph∆∞∆°ng tr√¨nh ph·∫£n ·ª©ng ƒë∆°n gi·∫£n
- C√¢n b·∫±ng ph∆∞∆°ng tr√¨nh h√≥a h·ªçc c∆° b·∫£n
- Nh·∫≠n bi·∫øt lo·∫°i ph·∫£n ·ª©ng (h√≥a h·ª£p, ph√¢n h·ªßy, th·∫ø, trao ƒë·ªïi)
- V√≠ d·ª•: "Ph∆∞∆°ng tr√¨nh n√†o sau ƒë√¢y ƒë∆∞·ª£c c√¢n b·∫±ng ƒë√∫ng?"

D·∫†NG 3: Nh·∫≠n bi·∫øt ·ª©ng d·ª•ng, vai tr√≤ trong ƒë·ªùi s·ªëng
- ·ª®ng d·ª•ng c·ªßa c√°c ch·∫•t trong c√¥ng nghi·ªáp, ƒë·ªùi s·ªëng
- T√°c h·∫°i v√† bi·ªán ph√°p ph√≤ng ch·ªëng √¥ nhi·ªÖm
- V√≠ d·ª•: "Ch·∫•t n√†o ƒë∆∞·ª£c d√πng l√†m ch·∫•t t·∫©y r·ª≠a?"
"""
            elif level == "Hi·ªÉu":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N I - M·ª®C ƒê·ªò HI·ªÇU (TH√îNG HI·ªÇU):
- M·ªói c√¢u c√≥ 4 ph∆∞∆°ng √°n A, B, C, D v·ªõi ch·ªâ 1 ƒë√°p √°n ƒë√∫ng
- Y√™u c·∫ßu gi·∫£i th√≠ch, so s√°nh, ho·∫∑c √°p d·ª•ng tr·ª±c ti·∫øp m·ªôt kh√°i ni·ªám ƒë√£ h·ªçc
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: So s√°nh t√≠nh ch·∫•t h√≥a h·ªçc/v·∫≠t l√Ω
- So s√°nh t√≠nh axit, t√≠nh baz∆°, nhi·ªát ƒë·ªô s√¥i, t√≠nh tan, kh·∫£ nƒÉng ph·∫£n ·ª©ng
- V√≠ d·ª•: "S·∫Øp x·∫øp theo chi·ªÅu tƒÉng d·∫ßn t√≠nh baz∆°: anilin, metylamin, amoniac, ƒëimetylamin"

D·∫†NG 2: Nh·∫≠n bi·∫øt hi·ªán t∆∞·ª£ng th√≠ nghi·ªám üß™
- M√¥ t·∫£ th√≠ nghi·ªám ƒë∆°n gi·∫£n v√† y√™u c·∫ßu ch·ªâ ra hi·ªán t∆∞·ª£ng quan s√°t
- M√†u s·∫Øc thay ƒë·ªïi, c√≥ k·∫øt t·ªßa, s·ªßi b·ªçt kh√≠, v.v.
- V√≠ d·ª•: "Cho dung d·ªãch iot v√†o ·ªëng nghi·ªám ch·ª©a h·ªì tinh b·ªôt. Hi·ªán t∆∞·ª£ng quan s√°t ƒë∆∞·ª£c l√† g√¨?"

D·∫†NG 3: X√°c ƒë·ªãnh ph√°t bi·ªÉu ƒê√∫ng/Sai (d·∫°ng ƒë∆°n gi·∫£n)
- ƒê∆∞a ra 4 ph√°t bi·ªÉu v·ªÅ m·ªôt ch·ªß ƒë·ªÅ c·ª• th·ªÉ (polime, kim lo·∫°i, ƒë·∫°i c∆∞∆°ng h·ªØu c∆°)
- V√≠ d·ª•: "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† ƒë√∫ng khi n√≥i v·ªÅ t∆° nilon-6,6?"

D·∫†NG 4: Danh ph√°p v√† C·∫•u t·∫°o
- Cho c√¥ng th·ª©c c·∫•u t·∫°o v√† y√™u c·∫ßu g·ªçi t√™n h·ª£p ch·∫•t ho·∫∑c ng∆∞·ª£c l·∫°i
- V√≠ d·ª•: "H·ª£p ch·∫•t CH‚ÇÉ-CH(CH‚ÇÉ)-COOH c√≥ t√™n g·ªçi l√† g√¨?"
"""
            elif level == "V·∫≠n_d·ª•ng":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N I - M·ª®C ƒê·ªò V·∫¨N D·ª§NG:
- M·ªói c√¢u c√≥ 4 ph∆∞∆°ng √°n A, B, C, D v·ªõi ch·ªâ 1 ƒë√°p √°n ƒë√∫ng
- Y√™u c·∫ßu t√≠nh to√°n ƒë∆°n gi·∫£n ho·∫∑c gi·∫£i quy·∫øt b√†i to√°n m·ªôt ho·∫∑c hai b∆∞·ªõc
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: B√†i to√°n Stoichiometry (t√≠nh theo ph∆∞∆°ng tr√¨nh h√≥a h·ªçc)
- Cho ph∆∞∆°ng tr√¨nh ph·∫£n ·ª©ng v·ªõi l∆∞·ª£ng ch·∫•t ·ªü m·ªôt v·∫ø, t√≠nh l∆∞·ª£ng ch·∫•t ·ªü v·∫ø c√≤n l·∫°i
- C√≥ th·ªÉ k·∫øt h·ª£p hi·ªáu su·∫•t ph·∫£n ·ª©ng ·ªü m·ª©c c∆° b·∫£n
- V√≠ d·ª•: "ƒê·ªët ch√°y ho√†n to√†n 6,4 gam ƒë·ªìng (Cu) trong oxi d∆∞, thu ƒë∆∞·ª£c m gam ƒë·ªìng(II) oxit (CuO). T√≠nh gi√° tr·ªã c·ªßa m."

D·∫†NG 2: B√†i to√°n v·ªÅ N·ªìng ƒë·ªô dung d·ªãch
- T√≠nh to√°n n·ªìng ƒë·ªô mol, n·ªìng ƒë·ªô ph·∫ßn trƒÉm
- B√†i to√°n pha lo√£ng, tr·ªôn l·∫´n dung d·ªãch kh√¥ng x·∫£y ra ph·∫£n ·ª©ng
- V√≠ d·ª•: "H√≤a tan 20 gam NaOH v√†o 180 gam n∆∞·ªõc thu ƒë∆∞·ª£c dung d·ªãch A. T√≠nh n·ªìng ƒë·ªô ph·∫ßn trƒÉm c·ªßa dung d·ªãch A."

D·∫†NG 3: X√°c ƒë·ªãnh c√¥ng th·ª©c ph√¢n t·ª≠ ƒë∆°n gi·∫£n
- D·ª±a v√†o ph·∫ßn trƒÉm kh·ªëi l∆∞·ª£ng c√°c nguy√™n t·ªë ho·∫∑c k·∫øt qu·∫£ ƒë·ªët ch√°y (ch·ªâ cho CO‚ÇÇ v√† H‚ÇÇO)
- T√¨m c√¥ng th·ª©c ƒë∆°n gi·∫£n nh·∫•t ho·∫∑c c√¥ng th·ª©c ph√¢n t·ª≠
- V√≠ d·ª•: "ƒê·ªët ch√°y ho√†n to√†n m·ªôt hiƒërocacbon X thu ƒë∆∞·ª£c 4,48 l√≠t CO‚ÇÇ (ƒëktc) v√† 3,6 gam H‚ÇÇO. T√¨m c√¥ng th·ª©c ph√¢n t·ª≠ c·ªßa X."
"""
        elif part_num == 2:
            if level == "Bi·∫øt":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N II - M·ª®C ƒê·ªò BI·∫æT:
- T·∫°o c√¢u h·ªèi ch√≠nh v·ªÅ m·ªôt ch·∫•t ho·∫∑c kh√°i ni·ªám c∆° b·∫£n
- Sau ƒë√≥ c√≥ 4 ph√°t bi·ªÉu a), b), c), d) ƒë·ªÉ ƒë√°nh gi√° ƒë√∫ng/sai
- Ki·ªÉm tra ki·∫øn th·ª©c l√Ω thuy·∫øt n·ªÅn t·∫£ng d∆∞·ªõi d·∫°ng ƒë√∫ng/sai
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: Ch√πm ph√°t bi·ªÉu v·ªÅ ƒë·ªãnh nghƒ©a v√† t√≠nh ch·∫•t c∆° b·∫£n
- C√°c nh·∫≠n ƒë·ªãnh v·ªÅ ƒë·ªãnh nghƒ©a, c√¥ng th·ª©c, t√≠nh ch·∫•t v·∫≠t l√Ω c∆° b·∫£n c·ªßa m·ªôt ch·∫•t
- V√≠ d·ª•: "Cho c√°c ph√°t bi·ªÉu v·ªÅ Glucose (C‚ÇÜH‚ÇÅ‚ÇÇO‚ÇÜ):"
  a) "Glucose l√† monosaccarit c√≥ 6 nguy√™n t·ª≠ cacbon"
  b) "Glucose c√≥ c√¥ng th·ª©c ph√¢n t·ª≠ C‚ÇÜH‚ÇÅ‚ÇÇO‚ÇÜ"
  c) "Glucose tan t·ªët trong n∆∞·ªõc"
  d) "Glucose c√≥ v·ªã ng·ªçt"

Format answer: {"a": {"content": "N·ªôi dung ph√°t bi·ªÉu a", "evaluation": "ƒê√∫ng/Sai"}, ...}
"""
            elif level == "Hi·ªÉu":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N II - M·ª®C ƒê·ªò HI·ªÇU (TH√îNG HI·ªÇU):

- T·∫°o c√¢u h·ªèi ch√≠nh v·ªÅ m·ªôt ch·∫•t ho·∫∑c t√¨nh hu·ªëng c·ª• th·ªÉ
- Sau ƒë√≥ c√≥ 4 ph√°t bi·ªÉu a), b), c), d) ƒë·ªÉ ƒë√°nh gi√° ƒë√∫ng/sai
- Ki·ªÉm tra kh·∫£ nƒÉng hi·ªÉu v√† gi·∫£i th√≠ch c√°c hi·ªán t∆∞·ª£ng, qu√° tr√¨nh h√≥a h·ªçc
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: Ch√πm ph√°t bi·ªÉu v·ªÅ m·ªôt ch·∫•t c·ª• th·ªÉ
- C·∫£ 4 nh·∫≠n ƒë·ªãnh ƒë·ªÅu xoay quanh m·ªôt ch·∫•t duy nh·∫•t (s·∫Øt, nh√¥m, glucoz∆°, saccaroz∆°, etyl axetat)
- C√°c ph√°t bi·ªÉu ki·ªÉm tra v·ªÅ c·∫•u tr√∫c, t√≠nh ch·∫•t v·∫≠t l√Ω, t√≠nh ch·∫•t h√≥a h·ªçc ƒë·∫∑c tr∆∞ng v√† ·ª©ng d·ª•ng
- V√≠ d·ª•: "Cho c√°c ph√°t bi·ªÉu v·ªÅ S·∫Øt (Fe):"
  a) "S·∫Øt l√† kim lo·∫°i c√≥ t√≠nh kh·ª≠ trung b√¨nh"
  b) "Trong t·ª± nhi√™n, s·∫Øt ch·ªâ t·ªìn t·∫°i ·ªü d·∫°ng h·ª£p ch·∫•t"
  c) "H·ª£p ch·∫•t S·∫Øt(II) v·ª´a c√≥ t√≠nh kh·ª≠ v·ª´a c√≥ t√≠nh oxi h√≥a"
  d) "Gang l√† h·ª£p kim c·ªßa s·∫Øt v·ªõi cacbon, c√≥ h√†m l∆∞·ª£ng cacbon t·ª´ 2-5%"

Format answer: {"a": {"content": "N·ªôi dung ph√°t bi·ªÉu a", "evaluation": "ƒê√∫ng/Sai"}, ...}
"""
            elif level == "V·∫≠n_d·ª•ng":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N II - M·ª®C ƒê·ªò V·∫¨N D·ª§NG:
- T·∫°o c√¢u h·ªèi ch√≠nh v·ªÅ m·ªôt t√¨nh hu·ªëng th·ª±c ti·ªÖn ho·∫∑c th√≠ nghi·ªám
- Sau ƒë√≥ c√≥ 4 ph√°t bi·ªÉu a), b), c), d) ƒë·ªÉ ƒë√°nh gi√° ƒë√∫ng/sai
- Y√™u c·∫ßu kh·∫£ nƒÉng li√™n k·∫øt ki·∫øn th·ª©c v·ªõi th·ª±c ti·ªÖn ho·∫∑c ph√¢n t√≠ch c√°c b∆∞·ªõc trong quy tr√¨nh
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: Ch√πm ph√°t bi·ªÉu m√¥ t·∫£ m·ªôt th√≠ nghi·ªám h√≥a h·ªçc üî¨
- C√°c nh·∫≠n ƒë·ªãnh m√¥ t·∫£ v·ªÅ m·ª•c ƒë√≠ch, c√°c b∆∞·ªõc ti·∫øn h√†nh, vai tr√≤ h√≥a ch·∫•t, hi·ªán t∆∞·ª£ng v√† gi·∫£i th√≠ch k·∫øt qu·∫£
- Th√≠ nghi·ªám c·ª• th·ªÉ: tr√°ng b·∫°c, x√† ph√≤ng h√≥a, ƒëi·ªÅu ch·∫ø este, ƒÉn m√≤n ƒëi·ªán h√≥a
- V√≠ d·ª•: "Cho c√°c ph√°t bi·ªÉu v·ªÅ th√≠ nghi·ªám ƒëi·ªÅu ch·∫ø Etyl axetat:"
  a) "H‚ÇÇSO‚ÇÑ ƒë·∫∑c ƒë∆∞·ª£c d√πng l√†m ch·∫•t x√∫c t√°c v√† tƒÉng hi·ªáu su·∫•t ph·∫£n ·ª©ng"
  b) "C√≥ th·ªÉ thay th·∫ø CH‚ÇÉCOOH b·∫±ng CH‚ÇÉCOONa ƒë·ªÉ th·ª±c hi·ªán ph·∫£n ·ª©ng"
  c) "Sau ph·∫£n ·ª©ng, este t·∫°o th√†nh n·ªïi l√™n tr√™n v√† c√≥ m√πi th∆°m"
  d) "M·ª•c ƒë√≠ch c·ªßa vi·ªác ch∆∞ng c·∫•t l√† ƒë·ªÉ tinh ch·∫ø este"

D·∫†NG 2: Ch√πm ph√°t bi·ªÉu v·ªÅ ·ª©ng d·ª•ng th·ª±c ti·ªÖn v√† h√≥a h·ªçc ƒë·ªùi s·ªëng
- C√°c nh·∫≠n ƒë·ªãnh li√™n quan ƒë·∫øn v·∫•n ƒë·ªÅ th·ª±c t·∫ø: polime v√† v·∫≠t li·ªáu, ph√¢n b√≥n h√≥a h·ªçc, h√≥a h·ªçc v√† m√¥i tr∆∞·ªùng, gang-th√©p, ƒÉn m√≤n kim lo·∫°i
- V√≠ d·ª•: "Cho c√°c ph√°t bi·ªÉu v·ªÅ Polime:"
  a) "Cao su buna-S ƒë∆∞·ª£c ƒëi·ªÅu ch·∫ø b·∫±ng ph·∫£n ·ª©ng tr√πng ng∆∞ng"
  b) "T∆° olon (nitron) ƒë∆∞·ª£c d√πng ƒë·ªÉ d·ªát v·∫£i may qu·∫ßn √°o ·∫•m"
  c) "Nh·ª±a PVC c√≥ t√≠nh c√°ch ƒëi·ªán t·ªët, ƒë∆∞·ª£c d√πng l√†m v·∫≠t li·ªáu c√°ch ƒëi·ªán"
  d) "Th·ªßy tinh h·ªØu c∆° (plexiglas) c√≥ th·ªÉ cho √°nh s√°ng truy·ªÅn qua t·ªët"

D·∫†NG 3: Ch√πm ph√°t bi·ªÉu k·∫øt h·ª£p t√≠nh to√°n nh·ªè
- Trong 4 nh·∫≠n ƒë·ªãnh, c√≥ 1-2 nh·∫≠n ƒë·ªãnh y√™u c·∫ßu ph√©p t√≠nh nh·∫©m ho·∫∑c t√≠nh to√°n nhanh
- V√≠ d·ª•: "Cho c√°c ph√°t bi·ªÉu v·ªÅ dung d·ªãch axit axetic 0,1M:"
  a) "Dung d·ªãch n√†y l√†m qu·ª≥ t√≠m h√≥a ƒë·ªè"
  b) "N·ªìng ƒë·ªô ion H‚Å∫ trong dung d·ªãch nh·ªè h∆°n 0,1M"
  c) "ƒê·ªÉ trung h√≤a 10ml dung d·ªãch n√†y c·∫ßn d√πng 10ml dung d·ªãch NaOH 0,1M"
  d) "Gi√° tr·ªã pH c·ªßa dung d·ªãch n√†y b·∫±ng 1"

Format answer: {"a": {"content": "N·ªôi dung ph√°t bi·ªÉu a", "evaluation": "ƒê√∫ng/Sai"}, ...}
"""
        elif part_num == 3:
            # PH·∫¶N III - T·ª∞ LU·∫¨N T√çNH TO√ÅN - H·ªñ TR·ª¢ T·∫§T C·∫¢ M·ª®C ƒê·ªò
            if level == "Bi·∫øt":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N III - M·ª®C ƒê·ªò BI·∫æT:
- C√¢u h·ªèi t·ª± lu·∫≠n ƒë∆°n gi·∫£n, √°p d·ª•ng tr·ª±c ti·∫øp c√¥ng th·ª©c c∆° b·∫£n
- ƒê√°p √°n l√† s·ªë th·ª±c d∆∞∆°ng, th∆∞·ªùng c√≥ gi√° tr·ªã ƒë∆°n gi·∫£n
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: T√≠nh to√°n c∆° b·∫£n theo c√¥ng th·ª©c
- √Åp d·ª•ng tr·ª±c ti·∫øp c√¥ng th·ª©c n = m/M, C = n/V, pH = -log[H‚Å∫]
- V√≠ d·ª•: "T√≠nh s·ªë mol c·ªßa 8g CuO" ho·∫∑c "T√≠nh n·ªìng ƒë·ªô mol c·ªßa dung d·ªãch ch·ª©a 0,1 mol NaCl trong 500ml"
D·∫†NG 2: T√≠nh to√°n theo ph∆∞∆°ng tr√¨nh h√≥a h·ªçc ƒë∆°n gi·∫£n
- Ph·∫£n ·ª©ng 1 b∆∞·ªõc, t·ªâ l·ªá mol ƒë∆°n gi·∫£n 1:1 ho·∫∑c 1:2
- V√≠ d·ª•: "Cho 0,1 mol Zn t√°c d·ª•ng v·ªõi HCl d∆∞. T√≠nh th·ªÉ t√≠ch H‚ÇÇ thu ƒë∆∞·ª£c ·ªü ƒëktc"

Y√™u c·∫ßu: ƒê√°p √°n ph·∫£i l√† s·ªë c·ª• th·ªÉ, s·ª≠ d·ª•ng c√¥ng th·ª©c c∆° b·∫£n.
"""
            elif level == "Hi·ªÉu":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N III - M·ª®C ƒê·ªò HI·ªÇU:
- C√¢u h·ªèi t·ª± lu·∫≠n y√™u c·∫ßu hi·ªÉu b·∫£n ch·∫•t ph·∫£n ·ª©ng v√† √°p d·ª•ng c√¥ng th·ª©c ph√π h·ª£p
- ƒê√°p √°n l√† s·ªë th·ª±c d∆∞∆°ng, c√≥ th·ªÉ c·∫ßn 2-3 b∆∞·ªõc t√≠nh to√°n
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: T√≠nh to√°n theo chu·ªói ph·∫£n ·ª©ng
- Ph·∫£n ·ª©ng 2-3 b∆∞·ªõc li√™n ti·∫øp, c·∫ßn hi·ªÉu m·ªëi li√™n h·ªá gi·ªØa c√°c ch·∫•t
- V√≠ d·ª•: "T·ª´ 11,2g Fe t·∫°o th√†nh FeCl‚ÇÉ qua 2 giai ƒëo·∫°n. T√≠nh kh·ªëi l∆∞·ª£ng FeCl‚ÇÉ thu ƒë∆∞·ª£c"
D·∫†NG 2: B√†i to√°n dung d·ªãch c∆° b·∫£n
- Pha lo√£ng, c√¥ c·∫°n, tr·ªôn dung d·ªãch v·ªõi t·ªâ l·ªá ƒë∆°n gi·∫£n
- V√≠ d·ª•: "Tr·ªôn 100ml dung d·ªãch NaCl 0,2M v·ªõi 200ml dung d·ªãch NaCl 0,1M. T√≠nh n·ªìng ƒë·ªô dung d·ªãch sau tr·ªôn"

Y√™u c·∫ßu: ƒê√°p √°n ph·∫£i l√† s·ªë c·ª• th·ªÉ, c·∫ßn hi·ªÉu b·∫£n ch·∫•t ƒë·ªÉ ch·ªçn c√¥ng th·ª©c ƒë√∫ng.
"""
            elif level == "V·∫≠n_d·ª•ng":
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N III - M·ª®C ƒê·ªò V·∫¨N D·ª§NG:
- C√¢u h·ªèi y√™u c·∫ßu √°p d·ª•ng c√¥ng th·ª©c v√† gi·∫£i quy·∫øt b√†i to√°n nhi·ªÅu b∆∞·ªõc trong b·ªëi c·∫£nh quen thu·ªôc
- ƒê√°p √°n l√† s·ªë th·ª±c d∆∞∆°ng, th∆∞·ªùng c√≥ gi√° tr·ªã l·ªõn (kg, t·∫•n, %, mol)
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: B√†i to√°n hi·ªáu su·∫•t trong s·∫£n xu·∫•t c√¥ng nghi·ªáp
- D·ª±a tr√™n quy tr√¨nh s·∫£n xu·∫•t th·ª±c t·∫ø (ƒëi·ªÅu ch·∫ø NH‚ÇÉ, H‚ÇÇSO‚ÇÑ, ƒëi·ªán ph√¢n Al‚ÇÇO‚ÇÉ, este h√≥a)
- Cho l∆∞·ª£ng nguy√™n li·ªáu v√† hi·ªáu su·∫•t ‚Üí t√≠nh l∆∞·ª£ng s·∫£n ph·∫©m (thu·∫≠n)
- Cho l∆∞·ª£ng s·∫£n ph·∫©m v√† hi·ªáu su·∫•t ‚Üí t√≠nh l∆∞·ª£ng nguy√™n li·ªáu (ngh·ªãch)
- V√≠ d·ª•: "S·∫£n xu·∫•t amoniac t·ª´ 10 t·∫•n N‚ÇÇ v·ªõi hi·ªáu su·∫•t 75%. T√≠nh kh·ªëi l∆∞·ª£ng NH‚ÇÉ thu ƒë∆∞·ª£c."
D·∫†NG 2: B√†i to√°n ƒë·ªët ch√°y h·ª£p ch·∫•t h·ªØu c∆°
- ƒê·ªët ch√°y ho√†n to√†n h·ª£p ch·∫•t h·ªØu c∆° (este, amin, cacbohidrat)
- D·ª±a v√†o kh·ªëi l∆∞·ª£ng/th·ªÉ t√≠ch CO‚ÇÇ, H‚ÇÇO, N‚ÇÇ ‚Üí t√¨m c√¥ng th·ª©c ph√¢n t·ª≠, % kh·ªëi l∆∞·ª£ng nguy√™n t·ªë
- V√≠ d·ª•: "ƒê·ªët ch√°y 0,1 mol este X thu ƒë∆∞·ª£c 0,4 mol CO‚ÇÇ v√† 0,3 mol H‚ÇÇO. T√≠nh ph·∫ßn trƒÉm C trong X."

Y√™u c·∫ßu: ƒê√°p √°n ph·∫£i l√† s·ªë c·ª• th·ªÉ, s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p b·∫£o to√†n nguy√™n t·ªë v√† t·ªâ l·ªá mol.
"""
            else:  # V·∫≠n d·ª•ng cao
                return """
H∆Ø·ªöNG D·∫™N PH·∫¶N III - M·ª®C ƒê·ªò V·∫¨N D·ª§NG CAO:
- C√¢u h·ªèi ph·ª©c t·∫°p, ƒë√≤i h·ªèi t∆∞ duy s√¢u, t·ªïng h·ª£p nhi·ªÅu m·∫£ng ki·∫øn th·ª©c
- S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p gi·∫£i to√°n n√¢ng cao (ƒë·ªìng ƒë·∫≥ng h√≥a, quy ƒë·ªïi, d·ªìn ch·∫•t)
C√≥ th·ªÉ tham kh·∫£o c√°c d·∫°ng b√™n d∆∞·ªõi:
D·∫†NG 1: B√†i to√°n bi·ªán lu·∫≠n h·ªón h·ª£p h·ªØu c∆° ph·ª©c t·∫°p
- H·ªón h·ª£p nhi·ªÅu ch·∫•t c√≥ c·∫•u tr√∫c t∆∞∆°ng t·ª± (este+axit, peptit+amino axit)
- Tham gia ƒë·ªìng th·ªùi nhi·ªÅu ph·∫£n ·ª©ng (th·ªßy ph√¢n + ƒë·ªët ch√°y)
- V√≠ d·ª•: "H·ªón h·ª£p X g·ªìm este v√† axit c√≥ c√πng s·ªë C. Th·ªßy ph√¢n X c·∫ßn a mol NaOH, ƒë·ªët ch√°y X thu ƒë∆∞·ª£c b mol CO‚ÇÇ. T√≠nh % kh·ªëi l∆∞·ª£ng este trong X."

D·∫†NG 2: B√†i to√°n V√¥ c∆° t·ªïng h·ª£p (Kim lo·∫°i + Axit oxi h√≥a m·∫°nh)
- H·ªón h·ª£p kim lo·∫°i v√† oxit t√°c d·ª•ng v·ªõi HNO‚ÇÉ/H‚ÇÇSO‚ÇÑ ƒë·∫∑c
- T·∫°o nhi·ªÅu s·∫£n ph·∫©m kh·ª≠ (NO, N‚ÇÇO, SO‚ÇÇ, NH‚ÇÑ‚Å∫)
- V√≠ d·ª•: "H·ªón h·ª£p Fe, Al, FeO t√°c d·ª•ng v·ªõi HNO‚ÇÉ t·∫°o NO v√† NH‚ÇÑNO‚ÇÉ. T√≠nh kh·ªëi l∆∞·ª£ng mu·ªëi khan."

D·∫†NG 3: B√†i to√°n ph√¢n t√≠ch ƒê·ªì th·ªã/B·∫£ng bi·ªÉu
- Ph√¢n t√≠ch d·ªØ li·ªáu qu√° tr√¨nh h√≥a h·ªçc (s·ª•c CO‚ÇÇ v√†o ki·ªÅm, nh·ªè axit v√†o mu·ªëi, ƒëi·ªán ph√¢n)
- D·ª±a v√†o ƒëi·ªÉm ƒë·∫∑c bi·ªát tr√™n ƒë·ªì th·ªã ‚Üí suy ra ƒë·∫°i l∆∞·ª£ng ban ƒë·∫ßu
- V√≠ d·ª•: "Cho ƒë·ªì th·ªã th·ªÉ t√≠ch CO‚ÇÇ theo th·ªùi gian khi s·ª•c v√†o Ba(OH)‚ÇÇ. T√≠nh n·ªìng ƒë·ªô Ba(OH)‚ÇÇ ban ƒë·∫ßu."

Y√™u c·∫ßu: S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p b·∫£o to√†n electron, ph√¢n t√≠ch k·ªπ l∆∞·ª°ng c√°c s·∫£n ph·∫©m c√≥ th·ªÉ t·∫°o th√†nh.
"""
        return ""

    def _get_answer_format_by_part(self, part_num: int) -> str:
        """Format ƒë√°p √°n theo t·ª´ng ph·∫ßn"""
        if part_num == 1:
            return '{"A": "Ph∆∞∆°ng √°n A", "B": "Ph∆∞∆°ng √°n B", "C": "Ph∆∞∆°ng √°n C", "D": "Ph∆∞∆°ng √°n D", "correct_answer": "A"}'
        elif part_num == 2:
            return '{"a": {"content": "Ph√°t bi·ªÉu a c·ª• th·ªÉ", "evaluation": "ƒê√∫ng"}, "b": {"content": "Ph√°t bi·ªÉu b c·ª• th·ªÉ", "evaluation": "Sai"}, "c": {"content": "Ph√°t bi·ªÉu c c·ª• th·ªÉ", "evaluation": "ƒê√∫ng"}, "d": {"content": "Ph√°t bi·ªÉu d c·ª• th·ªÉ", "evaluation": "Sai"}}'
        elif part_num == 3:
            return '{"answer": "S·ªë th·ª±c d∆∞∆°ng c·ª• th·ªÉ (VD: 12.5, 0.25, 75, 2.4)"}'
        return '{"correct_answer": "A"}'

    def _parse_llm_response(self, response_text: str, part_num: int, level: str, lesson_id: str) -> List[Dict[str, Any]]:
        """Parse response t·ª´ LLM"""
        try:
            # T√¨m JSON trong response
            start_idx = response_text.find('[')
            end_idx = response_text.rfind(']') + 1
            
            if start_idx == -1 or end_idx == 0:
                logger.error("No JSON array found in LLM response")
                return []

            json_str = response_text[start_idx:end_idx]
            questions = json.loads(json_str)

            # Validate v√† b·ªï sung th√¥ng tin
            validated_questions = []
            for q in questions:
                if isinstance(q, dict) and "question" in q:
                    q["part"] = part_num
                    q["cognitive_level"] = level
                    q["lesson_id"] = lesson_id
                    # X√°c ƒë·ªãnh lo·∫°i c√¢u h·ªèi theo ph·∫ßn
                    if part_num == 1:
                        q["question_type"] = "TN"  # Tr·∫Øc nghi·ªám nhi·ªÅu ph∆∞∆°ng √°n
                    elif part_num == 2:
                        q["question_type"] = "DS"  # ƒê√∫ng/Sai
                    elif part_num == 3:
                        q["question_type"] = "TL"  # T·ª± lu·∫≠n
                    else:
                        q["question_type"] = "TN"  # Default
                    validated_questions.append(q)

            return validated_questions

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON from LLM response: {e}")
            return []
        except Exception as e:
            logger.error(f"Error parsing LLM response: {e}")
            return []

    def _sort_and_renumber_questions(self, questions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """S·∫Øp x·∫øp c√¢u h·ªèi theo ph·∫ßn v√† ƒë√°nh s·ªë l·∫°i"""
        try:
            # S·∫Øp x·∫øp theo ph·∫ßn
            sorted_questions = sorted(questions, key=lambda x: x.get("part", 1))
            
            # ƒê√°nh s·ªë l·∫°i theo t·ª´ng ph·∫ßn
            part_counters = {1: 1, 2: 1, 3: 1}
            
            for question in sorted_questions:
                print(f"Question ne xt: {question}")
                part = question.get("part", 1)
                question["stt"] = part_counters[part]
                question["stt_global"] = len([q for q in sorted_questions[:sorted_questions.index(question)+1]])
                part_counters[part] += 1

            return sorted_questions

        except Exception as e:
            logger.error(f"Error sorting and renumbering questions: {e}")
            return questions

    def _calculate_statistics(
        self, questions: List[Dict[str, Any]], exam_request: SmartExamRequest, generation_time: float
    ) -> ExamStatistics:
        """T√≠nh to√°n th·ªëng k√™ ƒë·ªÅ thi"""
        try:
            # ƒê·∫øm c√¢u h·ªèi theo ph·∫ßn
            part_counts = {1: 0, 2: 0, 3: 0}
            difficulty_counts = {"Bi·∫øt": 0, "Hi·ªÉu": 0, "V·∫≠n_d·ª•ng": 0}
            
            for question in questions:
                part = question.get("part", 1)
                part_counts[part] += 1

                level = question.get("cognitive_level", "Bi·∫øt")
                if level in difficulty_counts:
                    difficulty_counts[level] += 1

            return ExamStatistics(
                total_questions=len(questions),
                part_1_questions=part_counts[1],
                part_2_questions=part_counts[2],
                part_3_questions=part_counts[3],
                lessons_used=len(exam_request.matrix),
                difficulty_distribution=difficulty_counts,
                generation_time=generation_time,
                created_at=datetime.now().isoformat()
            )

        except Exception as e:
            logger.error(f"Error calculating statistics: {e}")
            return ExamStatistics(
                total_questions=len(questions),
                part_1_questions=0,
                part_2_questions=0,
                part_3_questions=0,
                lessons_used=0,
                difficulty_distribution={"Bi·∫øt": 0, "Hi·ªÉu": 0, "V·∫≠n_d·ª•ng": 0},
                generation_time=generation_time,
                created_at=datetime.now().isoformat()
            )


# Factory function ƒë·ªÉ t·∫°o SmartExamGenerationService instance
def get_smart_exam_generation_service() -> SmartExamGenerationService:
    """
    T·∫°o SmartExamGenerationService instance m·ªõi

    Returns:
        SmartExamGenerationService: Fresh instance
    """
    return SmartExamGenerationService()




