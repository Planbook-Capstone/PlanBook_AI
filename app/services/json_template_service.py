"""
JSON Template Processing Service
X·ª≠ l√Ω slide generation v·ªõi JSON template t·ª´ frontend thay v√¨ Google Slides
"""

import logging
import re
import copy
from typing import Dict, List, Any, Optional
from datetime import datetime

from app.services.llm_service import get_llm_service
from app.services.textbook_retrieval_service import get_textbook_retrieval_service

logger = logging.getLogger(__name__)


class JsonTemplateService:
    """Service x·ª≠ l√Ω JSON template t·ª´ frontend"""
    
    def __init__(self):
        self.llm_service = get_llm_service()
        self.textbook_service = get_textbook_retrieval_service()

    def is_available(self) -> bool:
        """Ki·ªÉm tra service c√≥ s·∫µn s√†ng kh√¥ng"""
        return (
            self.llm_service and self.llm_service.is_available() and
            self.textbook_service is not None
        )
    
    async def process_json_template(
        self,
        lesson_id: str,
        template_json: Dict[str, Any],
        config_prompt: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        X·ª≠ l√Ω JSON template v·ªõi n·ªôi dung b√†i h·ªçc
        
        Args:
            lesson_id: ID c·ªßa b√†i h·ªçc
            template_json: JSON template t·ª´ frontend
            config_prompt: Prompt c·∫•u h√¨nh t√πy ch·ªânh
            
        Returns:
            Dict ch·ª©a template ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
        """
        try:
            logger.info(f"üîÑ Processing JSON template for lesson: {lesson_id}")
            logger.info(f"üîç Template JSON type: {type(template_json)}")
            logger.info(f"üîç Config prompt: {config_prompt}")

            # B∆∞·ªõc 1: L·∫•y n·ªôi dung b√†i h·ªçc
            lesson_content = await self._get_lesson_content(lesson_id)
            logger.info(f"üîç Lesson content result type: {type(lesson_content)}")
            logger.info(f"üîç Lesson content keys: {list(lesson_content.keys()) if isinstance(lesson_content, dict) else 'Not a dict'}")

            if not lesson_content.get("success", False):
                error_msg = lesson_content.get("error", "Unknown error in lesson content")
                raise Exception(error_msg)

            # B∆∞·ªõc 2: Ph√¢n t√≠ch template v√† detect placeholders
            try:
                analyzed_template = self._analyze_json_template(template_json)
                logger.info(f"üìä Analyzed template: {len(analyzed_template['slides'])} slides")
            except Exception as e:
                raise Exception(f"Failed to analyze template: {str(e)}")

            # B∆∞·ªõc 3: Sinh n·ªôi dung v·ªõi LLM
            presentation_content = await self._generate_presentation_content(
                lesson_content.get("content", ""),
                config_prompt
            )
            logger.info(f"üîç Presentation content result type: {type(presentation_content)}")
            logger.info(f"üîç Presentation content keys: {list(presentation_content.keys()) if isinstance(presentation_content, dict) else 'Not a dict'}")

            if not presentation_content.get("success", False):
                error_msg = presentation_content.get("error", "Unknown error in presentation content")
                raise Exception(error_msg)

            # B∆∞·ªõc 4: Map n·ªôi dung v√†o template
            try:
                processed_template = await self._map_content_to_json_template(
                    presentation_content.get("content", ""),
                    template_json,
                    analyzed_template
                )
            except Exception as e:
                raise Exception(f"Failed to map content to template: {str(e)}")

            # Tr·∫£ v·ªÅ k·∫øt qu·∫£ v·ªõi success flag
            return {
                "success": True,
                "lesson_id": lesson_id,
                "processed_template": processed_template,
                "slides_created": len(processed_template.get("slides", []))
            }

        except Exception as e:
            logger.error(f"‚ùå Error processing JSON template: {e}")
            # Tr·∫£ v·ªÅ l·ªói v·ªõi success flag
            return {
                "success": False,
                "error": f"Failed to process JSON template: {str(e)}",
                "lesson_id": lesson_id,
                "processed_template": {
                    "version": "1.0",
                    "createdAt": datetime.now().isoformat(),
                    "slideFormat": "16:9",
                    "slides": []
                },
                "slides_created": 0
            }
    
    async def _get_lesson_content(self, lesson_id: str) -> Dict[str, Any]:
        """L·∫•y n·ªôi dung b√†i h·ªçc t·ª´ TextbookRetrievalService"""
        try:
            logger.info(f"üìö Getting lesson content for: {lesson_id}")

            # S·ª≠ d·ª•ng TextbookRetrievalService ƒë·ªÉ l·∫•y lesson content
            lesson_result = await self.textbook_service.get_lesson_content(lesson_id)

            logger.info(f"üîç Lesson result keys: {list(lesson_result.keys())}")

            # Extract lesson content t·ª´ result
            lesson_content = lesson_result.get("lesson_content", "")

            if not lesson_content or not lesson_content.strip():
                logger.error(f"‚ùå No lesson content found for lesson_id: {lesson_id}")
                return {
                    "success": False,
                    "error": f"Empty lesson content for lesson_id: {lesson_id}"
                }

            logger.info(f"‚úÖ Retrieved lesson content: {len(lesson_content)} characters")
            logger.info(f"üìã Additional info - Book ID: {lesson_result.get('book_id')}, Total chunks: {lesson_result.get('total_chunks')}")

            return {
                "success": True,
                "content": lesson_content.strip(),
                "book_id": lesson_result.get("book_id"),
                "total_chunks": lesson_result.get("total_chunks"),
                "content_length": lesson_result.get("content_length")
            }

        except Exception as e:
            logger.error(f"‚ùå Error getting lesson content: {e}")
            return {
                "success": False,
                "error": f"Failed to get lesson content: {str(e)}"
            }
    
    def _analyze_json_template(self, template_json: Dict[str, Any]) -> Dict[str, Any]:
        """Ph√¢n t√≠ch JSON template v√† detect placeholders (theo logic c≈©)"""
        try:
            logger.info("üîç Analyzing JSON template structure...")
            logger.info(f"üîç Template JSON type: {type(template_json)}")
            logger.info(f"üîç Template JSON keys: {list(template_json.keys()) if isinstance(template_json, dict) else 'Not a dict'}")

            slides = template_json.get("slides", [])
            analyzed_slides = []

            # Placeholder patterns ƒë·ªÉ detect
            placeholder_patterns = {
                "LessonName": r"LessonName\s+(\d+)",
                "LessonDescription": r"LessonDescription\s+(\d+)",
                "CreatedDate": r"CreatedDate\s+(\d+)",
                "TitleName": r"TitleName\s+(\d+)",
                "TitleContent": r"TitleContent\s+(\d+)",
                "SubtitleName": r"SubtitleName\s+(\d+)",
                "SubtitleContent": r"SubtitleContent\s+(\d+)",
                "ImageName": r"ImageName\s+(\d+)",
                "ImageContent": r"ImageContent\s+(\d+)"
            }

            for slide in slides:
                analyzed_elements = []
                placeholder_counts = {}

                # Ph√¢n t√≠ch elements
                for element in slide.get("elements", []):
                    text = element.get("text", "").strip()

                    # Detect placeholder type t·ª´ text
                    placeholder_result = self._detect_placeholder_type_from_text(text, placeholder_patterns)

                    if placeholder_result:  # Ch·ªâ x·ª≠ l√Ω n·∫øu detect ƒë∆∞·ª£c placeholder
                        placeholder_type, max_length = placeholder_result

                        logger.info(f"‚úÖ Found placeholder: {placeholder_type} <{max_length}>")

                        # ƒê·∫øm s·ªë l∆∞·ª£ng placeholder types
                        placeholder_counts[placeholder_type] = placeholder_counts.get(placeholder_type, 0) + 1

                        # T·∫°o analyzed element v·ªõi th√¥ng tin ƒë·∫ßy ƒë·ªß
                        analyzed_element = {
                            "objectId": element.get("id"),
                            "text": None,  # LLM s·∫Ω insert n·ªôi dung sau
                            "Type": placeholder_type,
                            "max_length": max_length,
                            "original_element": element  # Gi·ªØ th√¥ng tin g·ªëc ƒë·ªÉ mapping
                        }

                        analyzed_elements.append(analyzed_element)
                    else:
                        # B·ªè qua text kh√¥ng ph·∫£i placeholder format
                        logger.info(f"‚ùå Skipping non-placeholder text: '{text}'")
                        continue

                # T·∫°o description cho slide d·ª±a tr√™n placeholder counts (nh∆∞ lu·ªìng c≈©)
                description = self._generate_slide_description(placeholder_counts)

                analyzed_slide = {
                    "slideId": slide.get("id"),
                    "description": description,
                    "elements": analyzed_elements,
                    "placeholder_counts": placeholder_counts,  # For logic selection
                    "original_slide": slide  # Gi·ªØ th√¥ng tin g·ªëc
                }

                analyzed_slides.append(analyzed_slide)

            result = {
                "slides": analyzed_slides,
                "total_slides": len(analyzed_slides),
                "slideFormat": template_json.get("slideFormat", "16:9"),
                "version": template_json.get("version", "1.0")
            }

            logger.info(f"‚úÖ Template analysis complete: {len(analyzed_slides)} slides analyzed")
            return result

        except Exception as e:
            logger.error(f"‚ùå Error analyzing JSON template: {e}")
            raise
    
    async def _generate_presentation_content(
        self,
        lesson_content: str,
        config_prompt: Optional[str] = None
    ) -> Dict[str, Any]:
        """Sinh n·ªôi dung presentation v·ªõi LLM"""
        try:
            logger.info("ü§ñ Generating presentation content with LLM...")

            # T·∫°o prompt cho LLM
            prompt = self._create_llm_prompt(lesson_content, config_prompt)
            
            # G·ªçi LLM
            llm_response = await self.llm_service.generate_content(
                prompt=prompt,
                max_tokens=60000,
                temperature=0.1
            )
            
            if not llm_response.get("success", False):
                return {
                    "success": False,
                    "error": f"LLM generation failed: {llm_response.get('error', 'Unknown error')}"
                }

            content = llm_response.get("text", "")  # LLMService tr·∫£ v·ªÅ "text" ch·ª© kh√¥ng ph·∫£i "content"
            logger.info(f"‚úÖ LLM content generated: {len(content)} characters")

            # Debug: Log first 500 chars of LLM content
            logger.info(f"üîç LLM content preview: {content[:500]}...")

            # Debug: Log full LLM content for debugging
            logger.info(f"üîç FULL LLM CONTENT DEBUG:")
            logger.info(f"Content length: {len(content)} characters")
            logger.info(f"Content: {content}")


            # Debug: Check for annotation patterns
            annotation_pattern = r'#\*\([^)]+\)\*#'
            annotation_matches = re.findall(annotation_pattern, content)
            logger.info(f"üîç Found {len(annotation_matches)} annotation patterns: {annotation_matches[:10]}")  # First 10

            return {
                "success": True,
                "content": content
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generating presentation content: {e}")
            return {
                "success": False,
                "error": f"Failed to generate content: {str(e)}"
            }
    
    def _create_llm_prompt(
        self,
        lesson_content: str,
        config_prompt: Optional[str] = None
    ) -> str:
        """T·∫°o prompt cho LLM theo format c·ªßa lu·ªìng c≈© (chi ti·∫øt v√† ch√≠nh x√°c)"""


        # C·∫£i thi·ªán default config ƒë·ªÉ t·∫°o n·ªôi dung chi ti·∫øt h∆°n
        default_config = """
B·∫°n l√† chuy√™n gia thi·∫øt k·∫ø n·ªôi dung thuy·∫øt tr√¨nh gi√°o d·ª•c chuy√™n nghi·ªáp. Nhi·ªám v·ª• c·ªßa b·∫°n l√† ph√¢n t√≠ch s√¢u n·ªôi dung b√†i h·ªçc v√† t·∫°o ra b√†i thuy·∫øt tr√¨nh chi ti·∫øt, ƒë·∫ßy ƒë·ªß v√† h·∫•p d·∫´n.
NGUY√äN T·∫ÆC THI·∫æT K·∫æ CH·∫§T L∆Ø·ª¢NG CAO:
1. PH√ÇN T√çCH TO√ÄN DI·ªÜN V√Ä S√ÇU S·∫ÆC:
   - Hi·ªÉu r√µ t·ª´ng kh√°i ni·ªám, ƒë·ªãnh nghƒ©a, c√¥ng th·ª©c trong b√†i h·ªçc
   - X√°c ƒë·ªãnh m·ªëi li√™n h·ªá gi·ªØa c√°c kh√°i ni·ªám
   - Ph√¢n t√≠ch v√≠ d·ª• minh h·ªça v√† ·ª©ng d·ª•ng th·ª±c t·∫ø
   - T√¨m ra c√°c ƒëi·ªÉm quan tr·ªçng c·∫ßn nh·∫•n m·∫°nh
2. C·∫§U TR√öC LOGIC V√Ä KHOA H·ªåC:
   - T·ª´ kh√°i ni·ªám c∆° b·∫£n ƒë·∫øn n√¢ng cao
   - T·ª´ l√Ω thuy·∫øt ƒë·∫øn ·ª©ng d·ª•ng th·ª±c t·∫ø
   - M·ªói slide c√≥ m·ª•c ƒë√≠ch r√µ r√†ng trong chu·ªói ki·∫øn th·ª©c
   - ƒê·∫£m b·∫£o t√≠nh li√™n k·∫øt gi·ªØa c√°c slide
3. N·ªòI DUNG PHONG PH√ö V√Ä CHI TI·∫æT:
   - T·∫°o √≠t nh·∫•t 10-12 slides v·ªõi n·ªôi dung ƒë·∫ßy ƒë·ªß v√† s√¢u s·∫Øc
   - M·ªói kh√°i ni·ªám ƒë∆∞·ª£c gi·∫£i th√≠ch r√µ r√†ng v·ªõi v√≠ d·ª• c·ª• th·ªÉ
   - B·ªï sung th√¥ng tin m·ªü r·ªông, ·ª©ng d·ª•ng th·ª±c t·∫ø
   - Kh√¥ng b·ªè s√≥t b·∫•t k·ª≥ th√¥ng tin quan tr·ªçng n√†o
4. NG√îN NG·ªÆ KHOA H·ªåC CH√çNH X√ÅC:
   - S·ª≠ d·ª•ng thu·∫≠t ng·ªØ khoa h·ªçc ch√≠nh x√°c
   - K√Ω hi·ªáu h√≥a h·ªçc, c√¥ng th·ª©c to√°n h·ªçc ƒë√∫ng chu·∫©n Unicode
   - Gi·∫£i th√≠ch thu·∫≠t ng·ªØ kh√≥ hi·ªÉu
   - Ng√¥n ng·ªØ r√µ r√†ng, d·ªÖ hi·ªÉu nh∆∞ng v·∫´n chuy√™n nghi·ªáp
5. V√ç D·ª§ V√Ä MINH H·ªåA PHONG PH√ö:
   - M·ªói kh√°i ni·ªám c√≥ th·ªÉ th√™m 1 v√≠ d·ª• n·∫øu c·∫ßn thi·∫øt
   - V√≠ d·ª• t·ª´ ƒë∆°n gi·∫£n ƒë·∫øn ph·ª©c t·∫°p
   - Li√™n h·ªá v·ªõi th·ª±c t·∫ø, ƒë·ªùi s·ªëng
   - B√†i t·∫≠p minh h·ªça c√≥ l·ªùi gi·∫£i chi ti·∫øt
Y√äU C·∫¶U ANNOTATION CH√çNH X√ÅC:
- PH·∫¢I c√≥ annotation b·∫±ng #*(PlaceholderType)*# ngay sau m·ªói n·ªôi dung
- Placeholder types: LessonName, LessonDescription, CreatedDate, TitleName, TitleContent, SubtitleName, SubtitleContent, ImageName, ImageContent
- Annotation ph·∫£i ch√≠nh x√°c 100% v√† nh·∫•t qu√°n
- B·∫ÆT BU·ªòC c√≥ slide summaries v·ªõi s·ªë l∆∞·ª£ng r√µ r√†ng ƒë·ªÉ ch·ªçn template ph√π h·ª£p
"""

        

        prompt = f"""
{default_config}
C√ÅC L∆ØU √ù NG∆Ø·ªúI T·∫†O (N·∫æU C√ì):
{config_prompt}
N·ªòI DUNG B√ÄI H·ªåC:
{lesson_content}
üìö H∆Ø·ªöNG D·∫™N T·∫†O PRESENTATION CONTENT CHI TI·∫æT:

1. PH√ÇN T√çCH B√ÄI H·ªåC S√ÇU S·∫ÆC:
   - ƒê·ªçc k·ªπ v√† hi·ªÉu r√µ t·ª´ng ƒëo·∫°n vƒÉn, kh√°i ni·ªám trong b√†i h·ªçc
   - X√°c ƒë·ªãnh ch·ªß ƒë·ªÅ ch√≠nh v√† t·∫•t c·∫£ c√°c ch·ªß ƒë·ªÅ ph·ª•
   - Ph√¢n lo·∫°i th√¥ng tin: ƒë·ªãnh nghƒ©a, c√¥ng th·ª©c, v√≠ d·ª•, ·ª©ng d·ª•ng
   - T√¨m ra m·ªëi li√™n h·ªá logic gi·ªØa c√°c kh√°i ni·ªám
   - X√°c ƒë·ªãnh ƒë·ªô kh√≥ v√† th·ª© t·ª± tr√¨nh b√†y h·ª£p l√Ω
   - TUY·ªÜT ƒê·ªêI KH√îNG ƒë∆∞·ª£c b·ªè s√≥t b·∫•t k·ª≥ th√¥ng tin quan tr·ªçng n√†o

2. T·∫†O N·ªòI DUNG V·ªöI ANNOTATION CH√çNH X√ÅC:
   - PH·∫¢I c√≥ annotation #*(PlaceholderType)*# ngay sau m·ªói n·ªôi dung
   - V√≠ d·ª•: "Nguy√™n t·ªë h√≥a h·ªçc v√† c·∫•u tr√∫c nguy√™n t·ª≠ #*(LessonName)*#"
   - V√≠ d·ª•: "B√†i h·ªçc n√†y gi√∫p h·ªçc sinh hi·ªÉu r√µ v·ªÅ c·∫•u tr√∫c nguy√™n t·ª≠, c√°c h·∫°t c∆° b·∫£n v√† t√≠nh ch·∫•t c·ªßa nguy√™n t·ªë h√≥a h·ªçc #*(LessonDescription)*#"
   - V√≠ d·ª•: "Ng√†y thuy·∫øt tr√¨nh: 18-07-2025 #*(CreatedDate)*#"
3. HI·ªÇU R√ï C·∫§U TR√öC PH√ÇN C·∫§P V√Ä NH√ìM N·ªòI DUNG CHI TI·∫æT:
   üìå TitleName: Ti√™u ƒë·ªÅ ch√≠nh c·ªßa slide (ng·∫Øn g·ªçn, s√∫c t√≠ch)
      - Ch·ªâ l√† t√™n ch·ªß ƒë·ªÅ, kh√¥ng ph·∫£i n·ªôi dung gi·∫£i th√≠ch
      - V√≠ d·ª•: "C·∫•u tr√∫c nguy√™n t·ª≠", "Li√™n k·∫øt h√≥a h·ªçc", "Ph·∫£n ·ª©ng oxi h√≥a kh·ª≠"
   üìù TitleContent: N·ªôi dung gi·∫£i th√≠ch chi ti·∫øt cho TitleName
      - Gi·∫£i th√≠ch ƒë·∫ßy ƒë·ªß kh√°i ni·ªám, ƒë·ªãnh nghƒ©a
      - Bao g·ªìm v√≠ d·ª• minh h·ªça c·ª• th·ªÉ
      - C√≥ th·ªÉ c√≥ nhi·ªÅu ƒëo·∫°n vƒÉn nh∆∞ng g·ªôp th√†nh m·ªôt kh·ªëi
   üî∏ SubtitleName: Ti√™u ƒë·ªÅ c√°c m·ª•c con trong ch·ªß ƒë·ªÅ ch√≠nh
      - C√°c kh√≠a c·∫°nh nh·ªè h∆°n c·ªßa ch·ªß ƒë·ªÅ ch√≠nh
      - V√≠ d·ª•: "Proton", "Neutron", "Electron" (trong ch·ªß ƒë·ªÅ C·∫•u tr√∫c nguy√™n t·ª≠)
   üìÑ SubtitleContent: N·ªôi dung chi ti·∫øt cho t·ª´ng SubtitleName
      - Gi·∫£i th√≠ch c·ª• th·ªÉ cho t·ª´ng m·ª•c con
      - C√≥ v√≠ d·ª•, c√¥ng th·ª©c, ·ª©ng d·ª•ng
      - QUAN TR·ªåNG: M·ªói SubtitleContent t∆∞∆°ng ·ª©ng v·ªõi ƒê√öNG M·ªòT SubtitleName (1:1 mapping)
      - TUY·ªÜT ƒê·ªêI KH√îNG t·∫°o nhi·ªÅu SubtitleContent ri√™ng bi·ªát cho c√πng 1 SubtitleName
      - G·ªôp t·∫•t c·∫£ n·ªôi dung c·ªßa 1 m·ª•c con th√†nh 1 kh·ªëi SubtitleContent duy nh·∫•t
4. V√ç D·ª§ CHI TI·∫æT V·ªöI C·∫§U TR√öC PH√ÇN C·∫§P R√ï R√ÄNG V√Ä N·ªòI DUNG PHONG PH√ö:
SLIDE 1 - GI·ªöI THI·ªÜU T·ªîNG QUAN:
Nguy√™n t·ªë h√≥a h·ªçc v√† b·∫£ng tu·∫ßn ho√†n #*(LessonName)*#
B√†i h·ªçc n√†y gi√∫p h·ªçc sinh hi·ªÉu r√µ v·ªÅ kh√°i ni·ªám nguy√™n t·ªë h√≥a h·ªçc, c·∫•u tr√∫c b·∫£ng tu·∫ßn ho√†n v√† m·ªëi li√™n h·ªá gi·ªØa v·ªã tr√≠ c·ªßa nguy√™n t·ªë v·ªõi t√≠nh ch·∫•t h√≥a h·ªçc. H·ªçc sinh s·∫Ω n·∫Øm ƒë∆∞·ª£c c√°ch ph√¢n lo·∫°i nguy√™n t·ªë v√† d·ª± ƒëo√°n t√≠nh ch·∫•t d·ª±a v√†o v·ªã tr√≠ trong b·∫£ng. #*(LessonDescription)*#
Ng√†y thuy·∫øt tr√¨nh: 18-07-2025 #*(CreatedDate)*#
=== SLIDE 1 SUMMARY ===
Placeholders: 1xLessonName, 1xLessonDescription, 1xCreatedDate
===========================
SLIDE 2 - KH√ÅI NI·ªÜM C∆† B·∫¢N V·ªöI N·ªòI DUNG CHI TI·∫æT:
Kh√°i ni·ªám nguy√™n t·ªë h√≥a h·ªçc #*(TitleName)*#
Nguy√™n t·ªë h√≥a h·ªçc l√† t·∫≠p h·ª£p c√°c nguy√™n t·ª≠ c√≥ c√πng s·ªë proton trong h·∫°t nh√¢n. M·ªói nguy√™n t·ªë ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi s·ªë hi·ªáu nguy√™n t·ª≠ (Z) - ch√≠nh l√† s·ªë proton trong h·∫°t nh√¢n. Hi·ªán nay, c√≥ 118 nguy√™n t·ªë ƒë√£ ƒë∆∞·ª£c ph√°t hi·ªán, trong ƒë√≥ 94 nguy√™n t·ªë t·ªìn t·∫°i trong t·ª± nhi√™n, c√≤n l·∫°i l√† nguy√™n t·ªë nh√¢n t·∫°o. M·ªói nguy√™n t·ªë c√≥ k√Ω hi·ªáu h√≥a h·ªçc ri√™ng, th∆∞·ªùng l√† 1-2 ch·ªØ c√°i, v√≠ d·ª•: H (hydro), He (heli), Li (lithi), Na (natri). C√°c nguy√™n t·ªë c√πng nh√≥m trong b·∫£ng tu·∫ßn ho√†n th∆∞·ªùng c√≥ t√≠nh ch·∫•t h√≥a h·ªçc t∆∞∆°ng t·ª± nhau do c√≥ c·∫•u h√¨nh electron h√≥a tr·ªã gi·ªëng nhau. #*(TitleContent)*#
=== SLIDE 2 SUMMARY ===
Placeholders: 1xTitleName, 1xTitleContent
===========================
SLIDE 3 - C·∫§U TR√öC NGUY√äN T·ª¨ CHI TI·∫æT:
C·∫•u tr√∫c nguy√™n t·ª≠ #*(TitleName)*#
Nguy√™n t·ª≠ l√† ƒë∆°n v·ªã c·∫•u t·∫°o c∆° b·∫£n c·ªßa v·∫≠t ch·∫•t, g·ªìm h·∫°t nh√¢n mang ƒëi·ªán t√≠ch d∆∞∆°ng ·ªü trung t√¢m v√† c√°c electron mang ƒëi·ªán t√≠ch √¢m chuy·ªÉn ƒë·ªông xung quanh. H·∫°t nh√¢n chi·∫øm ph·∫ßn l·ªõn kh·ªëi l∆∞·ª£ng nguy√™n t·ª≠ nh∆∞ng th·ªÉ t√≠ch r·∫•t nh·ªè (kho·∫£ng 10^-14 m) so v·ªõi k√≠ch th∆∞·ªõc nguy√™n t·ª≠ (kho·∫£ng 10^-10 m). #*(TitleContent)*#
H·∫°t nh√¢n nguy√™n t·ª≠ #*(SubtitleName)*#
H·∫°t nh√¢n nguy√™n t·ª≠ ƒë∆∞·ª£c c·∫•u t·∫°o t·ª´ proton v√† neutron (g·ªçi chung l√† nucleon). Proton mang ƒëi·ªán t√≠ch d∆∞∆°ng (+1), c√≥ kh·ªëi l∆∞·ª£ng kho·∫£ng 1,673 √ó 10^-27 kg. Neutron kh√¥ng mang ƒëi·ªán, c√≥ kh·ªëi l∆∞·ª£ng x·∫•p x·ªâ proton. L·ª±c h·∫°t nh√¢n m·∫°nh gi·ªØ c√°c nucleon l·∫°i v·ªõi nhau, v∆∞·ª£t qua l·ª±c ƒë·∫©y tƒ©nh ƒëi·ªán gi·ªØa c√°c proton. S·ªë proton trong h·∫°t nh√¢n x√°c ƒë·ªãnh nguy√™n t·ªë h√≥a h·ªçc, c√≤n s·ªë neutron c√≥ th·ªÉ thay ƒë·ªïi t·∫°o th√†nh c√°c ƒë·ªìng v·ªã. #*(SubtitleContent)*#
Electron v√† ƒë√°m m√¢y electron #*(SubtitleName)*#
Electron l√† h·∫°t mang ƒëi·ªán t√≠ch √¢m (-1), c√≥ kh·ªëi l∆∞·ª£ng r·∫•t nh·ªè (kho·∫£ng 9,109 √ó 10^-31 kg), ch·ªâ b·∫±ng 1/1836 kh·ªëi l∆∞·ª£ng proton. Electron chuy·ªÉn ƒë·ªông xung quanh h·∫°t nh√¢n trong c√°c orbital (ƒë√°m m√¢y electron) v·ªõi x√°c su·∫•t xu·∫•t hi·ªán kh√°c nhau. C√°c orbital ƒë∆∞·ª£c s·∫Øp x·∫øp th√†nh c√°c l·ªõp (K, L, M, N...) v√† c√°c ph√¢n l·ªõp (s, p, d, f). Electron ph√¢n b·ªë theo nguy√™n l√Ω Pauli, quy t·∫Øc Hund v√† nguy√™n l√Ω Aufbau. C·∫•u h√¨nh electron quy·∫øt ƒë·ªãnh t√≠nh ch·∫•t h√≥a h·ªçc c·ªßa nguy√™n t·ªë. #*(SubtitleContent)*#
=== SLIDE 3 SUMMARY ===
Placeholders: 1xTitleName, 1xTitleContent, 2xSubtitleName, 2xSubtitleContent
===========================
SLIDE 4 - B·∫¢NG TU·∫¶N HO√ÄN V√Ä XU H∆Ø·ªöNG:
B·∫£ng tu·∫ßn ho√†n c√°c nguy√™n t·ªë h√≥a h·ªçc #*(TitleName)*#
B·∫£ng tu·∫ßn ho√†n hi·ªán ƒë·∫°i #*(SubtitleName)*#
B·∫£ng tu·∫ßn ho√†n hi·ªán ƒë·∫°i g·ªìm 7 chu k·ª≥ (h√†ng ngang) v√† 18 nh√≥m (c·ªôt d·ªçc). C√°c nguy√™n t·ªë ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ª© t·ª± tƒÉng d·∫ßn c·ªßa s·ªë hi·ªáu nguy√™n t·ª≠. Chu k·ª≥ t∆∞∆°ng ·ª©ng v·ªõi s·ªë l·ªõp electron, nh√≥m t∆∞∆°ng ·ª©ng v·ªõi s·ªë electron h√≥a tr·ªã. B·∫£ng ƒë∆∞·ª£c chia th√†nh c√°c kh·ªëi: s, p, d, f t∆∞∆°ng ·ª©ng v·ªõi ph√¢n l·ªõp electron ngo√†i c√πng ƒëang ƒë∆∞·ª£c ƒëi·ªÅn. C√°c nguy√™n t·ªë trong c√πng nh√≥m c√≥ t√≠nh ch·∫•t h√≥a h·ªçc t∆∞∆°ng t·ª± do c√≥ c√πng c·∫•u h√¨nh electron h√≥a tr·ªã. #*(SubtitleContent)*#
Xu h∆∞·ªõng t√≠nh ch·∫•t trong b·∫£ng tu·∫ßn ho√†n #*(SubtitleName)*#
T√≠nh kim lo·∫°i gi·∫£m d·∫ßn t·ª´ tr√°i sang ph·∫£i trong chu k·ª≥ v√† tƒÉng d·∫ßn t·ª´ tr√™n xu·ªëng d∆∞·ªõi trong nh√≥m. B√°n k√≠nh nguy√™n t·ª≠ gi·∫£m d·∫ßn t·ª´ tr√°i sang ph·∫£i trong chu k·ª≥ v√† tƒÉng d·∫ßn t·ª´ tr√™n xu·ªëng d∆∞·ªõi trong nh√≥m. NƒÉng l∆∞·ª£ng ion h√≥a tƒÉng d·∫ßn t·ª´ tr√°i sang ph·∫£i trong chu k·ª≥ v√† gi·∫£m d·∫ßn t·ª´ tr√™n xu·ªëng d∆∞·ªõi trong nh√≥m. ƒê·ªô √¢m ƒëi·ªán tƒÉng d·∫ßn t·ª´ tr√°i sang ph·∫£i trong chu k·ª≥ v√† gi·∫£m d·∫ßn t·ª´ tr√™n xu·ªëng d∆∞·ªõi trong nh√≥m. C√°c xu h∆∞·ªõng n√†y gi√∫p d·ª± ƒëo√°n t√≠nh ch·∫•t v√† ph·∫£n ·ª©ng h√≥a h·ªçc c·ªßa c√°c nguy√™n t·ªë. #*(SubtitleContent)*#
=== SLIDE 4 SUMMARY ===
Placeholders: 1xTitleName, 2xSubtitleName, 2xSubtitleContent
===========================
... (ti·∫øp t·ª•c v·ªõi c√°c slide kh√°c t√πy theo n·ªôi dung b√†i h·ªçc)
5. QUY T·∫ÆC ANNOTATION V√Ä NH√ìM N·ªòI DUNG - C·ª∞C K·ª≤ QUAN TR·ªåNG:

üö® QUY T·∫ÆC NH√ìM N·ªòI DUNG B·∫ÆT BU·ªòC - C·ª∞C K·ª≤ QUAN TR·ªåNG:
- TUY·ªÜT ƒê·ªêI KH√îNG t·∫°o nhi·ªÅu TitleContent ri√™ng bi·ªát trong 1 TitleName
- TUY·ªÜT ƒê·ªêI KH√îNG t·∫°o nhi·ªÅu SubtitleContent ri√™ng bi·ªát cho c√πng 1 SubtitleName
- M·ªñI 1xTitleName CH·ªà C√ì T·ªêI ƒêA 1 TitleContent duy nh·∫•t (g·ªôp t·∫•t c·∫£ n·ªôi dung l·∫°i)
- M·ªñI SubtitleName CH·ªà C√ì ƒê√öNG 1 SubtitleContent t∆∞∆°ng ·ª©ng (1:1 mapping)

üî• V√ç D·ª§ SAI V·ªöI TITLECONTENT (TUY·ªÜT ƒê·ªêI KH√îNG L√ÄM):
C·∫•u tr√∫c nguy√™n t·ª≠ #*(TitleName)*#
Nguy√™n t·ª≠ g·ªìm h·∫°t nh√¢n v√† electron. #*(TitleContent)*#
H·∫°t nh√¢n ·ªü trung t√¢m. #*(TitleContent)*#  ‚ùå SAI - C√≥ 2 TitleContent ri√™ng bi·ªát
Electron chuy·ªÉn ƒë·ªông xung quanh. #*(TitleContent)*#  ‚ùå SAI - C√≥ 3 TitleContent ri√™ng bi·ªát

üî• V√ç D·ª§ SAI V·ªöI SUBTITLECONTENT (TUY·ªÜT ƒê·ªêI KH√îNG L√ÄM):
B√†i to√°n t√≠nh to√°n #*(SubtitleName)*#
G·ªçi x l√† ph·∫ßn trƒÉm s·ªë nguy√™n t·ª≠ c·ªßa ‚Å∂¬≥Cu. #*(SubtitleContent)*#
Ta c√≥ h·ªá ph∆∞∆°ng tr√¨nh: x + y = 100. #*(SubtitleContent)*#  ‚ùå SAI - C√≥ 2 SubtitleContent cho 1 SubtitleName
T·ª´ (1), ta c√≥ y = 100 - x. #*(SubtitleContent)*#  ‚ùå SAI - C√≥ 3 SubtitleContent cho 1 SubtitleName

‚úÖ V√ç D·ª§ ƒê√öNG V·ªöI TITLECONTENT (B·∫ÆT BU·ªòC L√ÄM THEO):
C·∫•u tr√∫c nguy√™n t·ª≠ #*(TitleName)*#
Nguy√™n t·ª≠ g·ªìm h·∫°t nh√¢n v√† electron. H·∫°t nh√¢n ·ªü trung t√¢m, ch·ª©a proton v√† neutron. Electron chuy·ªÉn ƒë·ªông xung quanh h·∫°t nh√¢n trong c√°c orbital. L·ª±c tƒ©nh ƒëi·ªán gi·ªØ electron g·∫ßn h·∫°t nh√¢n. #*(TitleContent)*#  ‚úÖ ƒê√öNG - Ch·ªâ 1 TitleContent duy nh·∫•t

‚úÖ V√ç D·ª§ ƒê√öNG V·ªöI SUBTITLECONTENT (B·∫ÆT BU·ªòC L√ÄM THEO):
B√†i to√°n t√≠nh to√°n #*(SubtitleName)*#
G·ªçi x l√† ph·∫ßn trƒÉm s·ªë nguy√™n t·ª≠ c·ªßa ‚Å∂¬≥Cu v√† y l√† ph·∫ßn trƒÉm s·ªë nguy√™n t·ª≠ c·ªßa ‚Å∂‚ÅµCu. Ta c√≥ h·ªá ph∆∞∆°ng tr√¨nh: x + y = 100 (T·ªïng ph·∫ßn trƒÉm l√† 100%) v√† (63x + 65y) / 100 = 63,54 (C√¥ng th·ª©c nguy√™n t·ª≠ kh·ªëi trung b√¨nh). T·ª´ (1), ta c√≥ y = 100 - x. Thay v√†o (2): (63x + 65(100 - x)) / 100 = 63,54. Gi·∫£i ph∆∞∆°ng tr√¨nh: 63x + 6500 - 65x = 6354, -2x = -146, x = 73. V·∫≠y ph·∫ßn trƒÉm s·ªë nguy√™n t·ª≠ c·ªßa ‚Å∂¬≥Cu l√† 73% v√† ‚Å∂‚ÅµCu l√† 27%. #*(SubtitleContent)*#  ‚úÖ ƒê√öNG - Ch·ªâ 1 SubtitleContent cho 1 SubtitleName
6. SLIDE SUMMARIES - ƒê·∫æMCH√çNH X√ÅC:
   Cu·ªëi m·ªói slide, th√™m slide summary v·ªõi S·ªê L∆Ø·ª¢NG CH√çNH X√ÅC:
   === SLIDE [S·ªë] SUMMARY ===
   Placeholders: [S·ªë l∆∞·ª£ng]x[PlaceholderType], [S·ªë l∆∞·ª£ng]x[PlaceholderType], ...

üö® L∆ØU √ù QUAN TR·ªåNG KHI ƒê·∫æM - QUY T·∫ÆC 1:1 MAPPING:
- TitleContent: LU√îN LU√îN ch·ªâ c√≥ 1 cho m·ªói TitleName (1 TitleName = 1 TitleContent)
- SubtitleContent: LU√îN LU√îN b·∫±ng s·ªë l∆∞·ª£ng SubtitleName (1 SubtitleName = 1 SubtitleContent)
- V√≠ d·ª• ƒë√∫ng: 1xTitleName, 1xTitleContent, 2xSubtitleName, 2xSubtitleContent
- V√≠ d·ª• sai: 1xTitleName, 3xTitleContent ‚ùå (kh√¥ng bao gi·ªù c√≥ nhi·ªÅu TitleContent)
- V√≠ d·ª• sai: 1xSubtitleName, 5xSubtitleContent ‚ùå (kh√¥ng bao gi·ªù c√≥ nhi·ªÅu SubtitleContent cho 1 SubtitleName)
   ===========================
7. Y√äU C·∫¶U OUTPUT CH·∫§T L∆Ø·ª¢NG CAO:
- T·∫°o n·ªôi dung thuy·∫øt tr√¨nh TEXT THU·∫¶N T√öY v·ªõi annotation ch√≠nh x√°c 100%
- N·ªôi dung chi ti·∫øt, ƒë·∫ßy ƒë·ªß, kh√¥ng b·ªè s√≥t th√¥ng tin quan tr·ªçng
- S·ª≠ d·ª•ng ng√¥n ng·ªØ khoa h·ªçc ch√≠nh x√°c, d·ªÖ hi·ªÉu
- C√≥ v√≠ d·ª• minh h·ªça c·ª• th·ªÉ cho m·ªói kh√°i ni·ªám
- B·∫ÆT BU·ªòC c√≥ slide summaries chi ti·∫øt ƒë·ªÉ ch·ªçn template ph√π h·ª£p
- Kh√¥ng t·∫°o ra b·∫£ng, s∆° ƒë·ªì - ch·ªâ s·ª≠ d·ª•ng text m√¥ t·∫£
- ƒê·∫£m b·∫£o t√≠nh logic v√† li√™n k·∫øt gi·ªØa c√°c slide
üîç V√ç D·ª§ MINH H·ªåA C·∫§U TR√öC ƒê√öNG V·ªöI NH√ìM N·ªòI DUNG:

SLIDE 1: (Slide n√†y l√† b·∫Øt bu·ªôc v√† lu√¥n c√≥)
C·∫•u h√¨nh electron #*(LessonName)*#
B√†i n√†y cho ch√∫ng ta bi·∫øt ƒë∆∞·ª£c c·∫•u h√¨nh electron trong nguy√™n t·ª≠ v√† ph√¢n t·ª≠ #*(LessonDescription)*#
Ng√†y thuy·∫øt tr√¨nh: 18-07-2025 #*(CreatedDate)*#
=== SLIDE 1 SUMMARY ===
Placeholders: 1xLessonName, 1xLessonDescription, 1xCreatedDate
===========================

SLIDE 2: (Slide ƒë∆°n gi·∫£n v·ªõi 1 TitleName v√† 1 TitleContent)
Kh√°i ni·ªám c·∫•u h√¨nh electron #*(TitleName)*#
C·∫•u h√¨nh electron l√† c√°ch s·∫Øp x·∫øp c√°c electron trong c√°c orbital c·ªßa nguy√™n t·ª≠. C·∫•u h√¨nh n√†y quy·∫øt ƒë·ªãnh t√≠nh ch·∫•t h√≥a h·ªçc c·ªßa nguy√™n t·ªë v√† kh·∫£ nƒÉng t·∫°o li√™n k·∫øt. Vi·ªác hi·ªÉu r√µ c·∫•u h√¨nh electron gi√∫p d·ª± ƒëo√°n t√≠nh ch·∫•t v√† h√†nh vi c·ªßa c√°c nguy√™n t·ªë trong ph·∫£n ·ª©ng h√≥a h·ªçc. M·ªói orbital c√≥ m·ª©c nƒÉng l∆∞·ª£ng v√† h√¨nh d·∫°ng kh√°c nhau. C√°c electron s·∫Ω l·∫•p ƒë·∫ßy c√°c orbital theo th·ª© t·ª± nƒÉng l∆∞·ª£ng tƒÉng d·∫ßn. #*(TitleContent)*#
=== SLIDE 2 SUMMARY ===
Placeholders: 1xTitleName, 1xTitleContent
===========================

SLIDE 3: (Slide v·ªõi TitleName, TitleContent v√† c√°c SubtitleName, SubtitleContent)
C√°c quy t·∫Øc s·∫Øp x·∫øp electron #*(TitleName)*#
C√°c electron trong nguy√™n t·ª≠ tu√¢n theo m·ªôt s·ªë quy t·∫Øc nh·∫•t ƒë·ªãnh khi s·∫Øp x·∫øp v√†o c√°c orbital. Vi·ªác hi·ªÉu r√µ c√°c quy t·∫Øc n√†y gi√∫p ch√∫ng ta x√°c ƒë·ªãnh c·∫•u h√¨nh electron ch√≠nh x√°c v√† d·ª± ƒëo√°n t√≠nh ch·∫•t h√≥a h·ªçc c·ªßa nguy√™n t·ªë. #*(TitleContent)*#
Quy t·∫Øc Aufbau #*(SubtitleName)*#
Electron ƒëi·ªÅn v√†o orbital c√≥ m·ª©c nƒÉng l∆∞·ª£ng th·∫•p tr∆∞·ªõc, sau ƒë√≥ m·ªõi ƒëi·ªÅn v√†o orbital c√≥ m·ª©c nƒÉng l∆∞·ª£ng cao h∆°n theo quy t·∫Øc Aufbau. Th·ª© t·ª± nƒÉng l∆∞·ª£ng tƒÉng d·∫ßn c·ªßa c√°c orbital l√†: 1s < 2s < 2p < 3s < 3p < 4s < 3d < 4p < 5s < 4d < 5p < 6s < 4f < 5d < 6p < 7s < 5f. #*(SubtitleContent)*#
Nguy√™n l√Ω Pauli #*(SubtitleName)*#
M·ªói orbital ch·ª©a t·ªëi ƒëa 2 electron v√† ch√∫ng ph·∫£i c√≥ spin ng∆∞·ª£c chi·ªÅu nhau theo nguy√™n l√Ω Pauli. ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† kh√¥ng c√≥ hai electron trong m·ªôt nguy√™n t·ª≠ c√≥ th·ªÉ c√≥ c·∫£ b·ªën s·ªë l∆∞·ª£ng t·ª≠ gi·ªëng nhau. Nguy√™n l√Ω n√†y gi·∫£i th√≠ch t·∫°i sao c√°c electron kh√¥ng th·ªÉ t·∫≠p trung h·∫øt v√†o orbital nƒÉng l∆∞·ª£ng th·∫•p nh·∫•t. #*(SubtitleContent)*#
=== SLIDE 3 SUMMARY ===
Placeholders: 1xTitleName, 1xTitleContent, 2xSubtitleName, 2xSubtitleContent
===========================

SLIDE 4: (Slide v·ªõi ImageName v√† ImageContent)
H√¨nh ·∫£nh minh h·ªça: S∆° ƒë·ªì c·∫•u h√¨nh electron #*(ImageName)*#
S∆° ƒë·ªì th·ªÉ hi·ªán c√°ch electron ƒë∆∞·ª£c s·∫Øp x·∫øp trong c√°c orbital 1s, 2s, 2p theo th·ª© t·ª± nƒÉng l∆∞·ª£ng tƒÉng d·∫ßn. C√°c m≈©i t√™n h∆∞·ªõng l√™n v√† xu·ªëng bi·ªÉu th·ªã electron v·ªõi spin kh√°c nhau. M·ªói √¥ vu√¥ng ƒë·∫°i di·ªán cho m·ªôt orbital. C√°c orbital c√πng ph√¢n l·ªõp c√≥ c√πng m·ª©c nƒÉng l∆∞·ª£ng. #*(ImageContent)*#
=== SLIDE 4 SUMMARY ===
Placeholders: 1xImageName, 1xImageContent
===========================

SLIDE 5: (Slide ph·ª©c t·∫°p v·ªõi nhi·ªÅu SubtitleName v√† SubtitleContent)
·ª®ng d·ª•ng c·∫•u h√¨nh electron #*(TitleName)*#
C·∫•u h√¨nh electron c√≥ nhi·ªÅu ·ª©ng d·ª•ng quan tr·ªçng trong h√≥a h·ªçc, v·∫≠t l√Ω v√† khoa h·ªçc v·∫≠t li·ªáu. Hi·ªÉu r√µ c·∫•u h√¨nh electron gi√∫p ch√∫ng ta gi·∫£i th√≠ch v√† d·ª± ƒëo√°n nhi·ªÅu hi·ªán t∆∞·ª£ng trong t·ª± nhi√™n. #*(TitleContent)*#
D·ª± ƒëo√°n t√≠nh ch·∫•t h√≥a h·ªçc #*(SubtitleName)*#
C·∫•u h√¨nh electron c·ªßa l·ªõp ngo√†i c√πng (electron h√≥a tr·ªã) quy·∫øt ƒë·ªãnh t√≠nh ch·∫•t h√≥a h·ªçc c·ªßa nguy√™n t·ªë. C√°c nguy√™n t·ªë c√≥ c·∫•u h√¨nh electron h√≥a tr·ªã gi·ªëng nhau th∆∞·ªùng c√≥ t√≠nh ch·∫•t h√≥a h·ªçc t∆∞∆°ng t·ª±. V√≠ d·ª•: Na v√† K ƒë·ªÅu c√≥ 1 electron ·ªü l·ªõp ngo√†i c√πng n√™n ƒë·ªÅu l√† kim lo·∫°i ki·ªÅm c√≥ t√≠nh kh·ª≠ m·∫°nh. #*(SubtitleContent)*#
Gi·∫£i th√≠ch li√™n k·∫øt h√≥a h·ªçc #*(SubtitleName)*#
C·∫•u h√¨nh electron gi√∫p gi·∫£i th√≠ch c√°ch c√°c nguy√™n t·ª≠ li√™n k·∫øt v·ªõi nhau. Nguy√™n t·ª≠ c√≥ xu h∆∞·ªõng ƒë·∫°t ƒë∆∞·ª£c c·∫•u h√¨nh electron b·ªÅn v·ªØng (8 electron ·ªü l·ªõp ngo√†i c√πng) th√¥ng qua vi·ªác nh·∫≠n, cho ho·∫∑c chia s·∫ª electron, t·∫°o th√†nh li√™n k·∫øt ion ho·∫∑c li√™n k·∫øt c·ªông h√≥a tr·ªã. #*(SubtitleContent)*#
Ph√°t tri·ªÉn v·∫≠t li·ªáu m·ªõi #*(SubtitleName)*#
Hi·ªÉu bi·∫øt v·ªÅ c·∫•u h√¨nh electron gi√∫p c√°c nh√† khoa h·ªçc thi·∫øt k·∫ø v√† ph√°t tri·ªÉn v·∫≠t li·ªáu m·ªõi v·ªõi t√≠nh ch·∫•t ƒë·∫∑c bi·ªát nh∆∞ ch·∫•t b√°n d·∫´n, si√™u d·∫´n, v·∫≠t li·ªáu t·ª´ t√≠nh v√† v·∫≠t li·ªáu quang h·ªçc. #*(SubtitleContent)*#
=== SLIDE 5 SUMMARY ===
Placeholders: 1xTitleName, 1xTitleContent, 3xSubtitleName, 3xSubtitleContent
===========================
8. QUY T·∫ÆC VI·∫æT CHI TI·∫æT V√Ä CH√çNH X√ÅC:

* ANNOTATION B·∫ÆT BU·ªòC:
- LU√îN c√≥ annotation #*(PlaceholderType)*# ngay sau m·ªói n·ªôi dung
- Kh√¥ng ƒë∆∞·ª£c thi·∫øu ho·∫∑c sai annotation
- Ki·ªÉm tra k·ªπ tr∆∞·ªõc khi ho√†n th√†nh

* N·ªòI DUNG CH·∫§T L∆Ø·ª¢NG:
- N·ªôi dung ƒë·∫ßy ƒë·ªß, chi ti·∫øt, kh√¥ng b·ªè s√≥t ki·∫øn th·ª©c n√†o
- M·ªói kh√°i ni·ªám c√≥ ƒë·ªãnh nghƒ©a r√µ r√†ng v√† v√≠ d·ª• minh h·ªça
- Gi·∫£i th√≠ch t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao
- Li√™n h·ªá v·ªõi th·ª±c t·∫ø v√† ·ª©ng d·ª•ng

* C·∫§U TR√öC PH√ÇN C·∫§P R√ï R√ÄNG V√Ä QUY T·∫ÆC 1:1 MAPPING:
- TitleName: CH·ªà l√† ti√™u ƒë·ªÅ ch√≠nh
- TitleContent: N·ªôi dung gi·∫£i th√≠ch chi ti·∫øt (CH·ªà 1 kh·ªëi cho m·ªói TitleName)
- SubtitleName: Ti√™u ƒë·ªÅ m·ª•c con
- SubtitleContent: N·ªôi dung chi ti·∫øt m·ª•c con (CH·ªà 1 kh·ªëi cho m·ªói SubtitleName)

* SLIDE SUMMARIES CH√çNH X√ÅC:
- ƒê·∫øm ch√≠nh x√°c s·ªë l∆∞·ª£ng t·ª´ng placeholder type
- Format: === SLIDE [S·ªë] SUMMARY ===
- V√≠ d·ª•: Placeholders: 1xTitleName, 2xSubtitleName, 2xSubtitleContent
  * TitleContent: T·∫§T C·∫¢ n·ªôi dung gi·∫£i th√≠ch c·ªßa m·ª•c l·ªõn ƒë∆∞·ª£c g·ªôp chung th√†nh 1 kh·ªëi
  * SubtitleName: CH·ªà l√† ti√™u ƒë·ªÅ m·ª•c nh·ªè b√™n trong m·ª•c l·ªõn
  * SubtitleContent: T·∫§T C·∫¢ n·ªôi dung gi·∫£i th√≠ch c·ªßa t·ª´ng m·ª•c nh·ªè ƒë∆∞·ª£c g·ªôp chung th√†nh 1 kh·ªëi
- K√Ω hi·ªáu khoa h·ªçc ch√≠nh x√°c: H‚ÇÇO, CO‚ÇÇ, x¬≤, ‚àöx, œÄ, Œ±, Œ≤
- S·ª≠ d·ª•ng ng√†y hi·ªán t·∫°i cho CreatedDate

üî• NH·∫ÆC NH·ªû CU·ªêI C√ôNG - QUY T·∫ÆC QUAN TR·ªåNG NH·∫§T:
*Kh√¥ng t·∫°o ra b·∫£ng, s∆° ƒë·ªì - ch·ªâ s·ª≠ d·ª•ng text m√¥ t·∫£
*TUY·ªÜT ƒê·ªêI TU√ÇN TH·ª¶ QUY T·∫ÆC 1:1 MAPPING:
- M·ªói SubtitleName ch·ªâ c√≥ ƒê√öNG 1 SubtitleContent t∆∞∆°ng ·ª©ng
- N·∫øu c√≥ nhi·ªÅu c√¢u/ƒëo·∫°n vƒÉn cho 1 m·ª•c con, h√£y g·ªôp t·∫•t c·∫£ th√†nh 1 SubtitleContent duy nh·∫•t
- V√≠ d·ª•: Thay v√¨ t·∫°o 5 SubtitleContent ri√™ng bi·ªát, h√£y g·ªôp th√†nh 1 SubtitleContent d√†i
- ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o template matching ch√≠nh x√°c v√† tr√°nh l·ªói mapping
"""

        return prompt

    def _detect_placeholder_type_from_text(self, text: str, placeholder_patterns: Dict[str, str]) -> Optional[tuple]:
        """
        Detect placeholder type v√† max_length t·ª´ text format "PlaceholderName max_length"

        Args:
            text: Text t·ª´ element
            placeholder_patterns: Dictionary c·ªßa patterns

        Returns:
            tuple: (placeholder_type, max_length) ho·∫∑c None n·∫øu kh√¥ng detect ƒë∆∞·ª£c
        """
        try:
            for placeholder_type, pattern in placeholder_patterns.items():
                match = re.search(pattern, text)
                if match:
                    max_length = int(match.group(1))
                    return placeholder_type, max_length

            return None

        except Exception as e:
            logger.warning(f"Error detecting placeholder type: {e}")
            return None

    def _generate_slide_description(self, placeholder_counts: Dict[str, int]) -> str:
        """
        Generate description for slide based on placeholder counts (t·ª´ lu·ªìng c≈©)

        Args:
            placeholder_counts: Dictionary of placeholder type counts

        Returns:
            str: Generated description
        """
        try:
            if not placeholder_counts:
                return "Slide tr·ªëng"

            descriptions = []
            for placeholder_type, count in placeholder_counts.items():
                if count > 0:
                    if count == 1:
                        descriptions.append(f"1 {placeholder_type}")
                    else:
                        descriptions.append(f"{count} {placeholder_type}")

            if descriptions:
                return f"Slide d√†nh cho {', '.join(descriptions)}"
            else:
                return "Slide tr·ªëng"

        except Exception as e:
            logger.warning(f"Error generating slide description: {e}")
            return "Slide kh√¥ng x√°c ƒë·ªãnh"

    async def _map_content_to_json_template(
        self,
        llm_content: str,
        original_template: Dict[str, Any],
        analyzed_template: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Map n·ªôi dung LLM v√†o JSON template theo logic c·ªßa lu·ªìng c≈© v·ªõi intelligent slide selection"""
        try:
            logger.info("üîß Mapping LLM content to JSON template with intelligent slide selection...")

            # Parse LLM content v·ªõi slide summaries
            parsed_data = self._parse_llm_content(llm_content)
            slide_summaries = parsed_data.get("_slide_summaries", [])

            if not slide_summaries:
                logger.error("‚ùå No slide summaries found in LLM content")
                raise ValueError("No slide summaries found - cannot perform intelligent slide selection")

            # Create processed template copy
            processed_template = {
                "version": original_template.get("version", "1.0"),
                "createdAt": datetime.now().isoformat(),
                "slideFormat": original_template.get("slideFormat", "16:9"),
                "slides": []
            }

            # Content index ƒë·ªÉ track vi·ªác s·ª≠ d·ª•ng content (nh∆∞ lu·ªìng c≈©)
            content_index = {
                "LessonName": 0,
                "LessonDescription": 0,
                "CreatedDate": 0,
                "TitleName": 0,
                "TitleContent": 0,
                "SubtitleName": 0,
                "SubtitleContent": 0,
                "ImageName": 0,
                "ImageContent": 0
            }

            # Track used slides ƒë·ªÉ tr√°nh duplicate
            used_slide_ids = set()
            template_slides = analyzed_template.get("slides", [])

            logger.info(f"ÔøΩ Processing {len(slide_summaries)} slide summaries with intelligent matching...")

            # Process t·ª´ng slide summary v·ªõi intelligent template selection
            for i, summary in enumerate(slide_summaries):
                slide_num = i + 1
                required_placeholders = summary.get("placeholders", [])
                required_counts = summary.get("placeholder_counts", {})

                logger.info(f"üîç Processing slide {slide_num}:")
                logger.info(f"   Required placeholders: {required_placeholders}")
                logger.info(f"   Required counts: {required_counts}")



                # T√¨m template ph√π h·ª£p CH√çNH X√ÅC (kh√¥ng fallback)
                # ƒê·∫ßu ti√™n th·ª≠ t√¨m template ch∆∞a s·ª≠ d·ª•ng
                best_template = self._find_exact_matching_template(
                    required_placeholders,
                    required_counts,
                    template_slides,
                    used_slide_ids
                )

                # N·∫øu kh√¥ng t√¨m th·∫•y template ch∆∞a s·ª≠ d·ª•ng, cho ph√©p reuse template
                if not best_template:
                    logger.info(f"üîÑ No unused template found, trying to reuse existing template...")
                    best_template = self._find_exact_matching_template_with_reuse(
                        required_placeholders,
                        required_counts,
                        template_slides
                    )

                if best_template:
                    template_id = best_template['slideId']
                    is_reused = template_id in used_slide_ids

                    if is_reused:
                        logger.info(f"‚úÖ Found exact matching template (REUSED): {template_id}")
                    else:
                        logger.info(f"‚úÖ Found exact matching template (NEW): {template_id}")

                    # T·∫°o processed slide t·ª´ template
                    processed_slide = await self._create_processed_slide_from_template(
                        best_template,
                        parsed_data,
                        content_index,
                        slide_num,
                        is_reused
                    )

                    if processed_slide:
                        processed_template["slides"].append(processed_slide)
                        # Ch·ªâ th√™m v√†o used_slide_ids n·∫øu ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng
                        if not is_reused:
                            used_slide_ids.add(template_id)
                        logger.info(f"‚úÖ Successfully processed slide {slide_num} ({'reused' if is_reused else 'new'})")
                    else:
                        logger.error(f"‚ùå Failed to create processed slide {slide_num} - SKIPPING")
                        # Kh√¥ng fallback - skip slide n√†y
                        continue
                else:
                    logger.error(f"‚ùå No exact matching template found for slide {slide_num} - SKIPPING")
                    # Kh√¥ng fallback - skip slide n√†y
                    continue

            logger.info(f"‚úÖ Template processing complete: {len(processed_template['slides'])} slides created")
            return processed_template

        except Exception as e:
            logger.error(f"‚ùå Error mapping content to template: {e}")
            raise

    def _parse_llm_content(self, llm_content: str) -> Dict[str, List[Dict[str, Any]]]:
        """Parse n·ªôi dung t·ª´ LLM theo format c·ªßa lu·ªìng c≈© v·ªõi slide summaries"""
        try:
            logger.info("üìù Parsing LLM content with slide summaries...")

            parsed_data = {
                "LessonName": [],
                "LessonDescription": [],
                "CreatedDate": [],
                "TitleName": [],
                "TitleContent": [],
                "SubtitleName": [],
                "SubtitleContent": [],
                "ImageName": [],
                "ImageContent": []
            }

            # Parse content theo annotation format - LLM sinh theo format: "content #*(PlaceholderType)*#"
            valid_placeholders = '|'.join(parsed_data.keys())

            # T√°ch content theo t·ª´ng d√≤ng v√† match t·ª´ng d√≤ng
            lines = llm_content.split('\n')
            matches = []

            for line in lines:
                # Pattern ƒë·ªÉ match: "content #*(PlaceholderType)*#" trong m·ªôt d√≤ng
                pattern = rf'(.+?)\s*#\*\(({valid_placeholders})\)\*#'
                line_matches = re.findall(pattern, line, re.IGNORECASE)
                matches.extend(line_matches)

            logger.info(f"üîç Found {len(matches)} annotation matches")
            logger.info(f"üîç Pattern used: {pattern}")
            logger.info(f"üîç Total lines processed: {len(lines)}")

            # Debug: Log some sample lines to see format
            logger.info(f"üîç Sample lines with potential annotations:")
            for i, line in enumerate(lines[:20]):  # First 20 lines
                if '#*(' in line and ')*#' in line:
                    logger.info(f"  Line {i+1}: {line}")

            for content, placeholder_type in matches:
                clean_content = content.strip()
                if clean_content:
                    parsed_data[placeholder_type].append({
                        "content": clean_content,
                        "length": len(clean_content)
                    })
                    logger.info(f"‚úÖ Parsed {placeholder_type}: {clean_content}...")
                else:
                    logger.warning(f"‚ùå Empty content for {placeholder_type}")

            # Debug: Log parsed data summary
            logger.info(f"üîç PARSED DATA SUMMARY:")
            for placeholder_type, items in parsed_data.items():
                if items:
                    logger.info(f"  {placeholder_type}: {len(items)} items")
                    for i, item in enumerate(items[:3]):  # First 3 items
                        logger.info(f"    [{i+1}] {item['content']}...")
                else:
                    logger.info(f"  {placeholder_type}: 0 items")

            # Parse slide summaries ƒë·ªÉ hi·ªÉu c·∫•u tr√∫c (nh∆∞ lu·ªìng c≈©)
            slide_summaries = []
            summary_pattern = r'=== SLIDE (\d+) SUMMARY ===\s*Placeholders:\s*([^=]+)'
            summary_matches = re.findall(summary_pattern, llm_content, re.IGNORECASE)

            # Debug: Log LLM content v√† summary matches
            logger.info(f"üîç LLM content length: {len(llm_content)} characters")
            logger.info(f"üîç Summary pattern: {summary_pattern}")
            logger.info(f"üîç Found {len(summary_matches)} summary matches")
            if len(summary_matches) == 0:
                logger.warning("‚ùå No slide summaries found! LLM content preview:")
                logger.warning(f"First 1000 chars: {llm_content[:1000]}")
                logger.warning(f"Last 1000 chars: {llm_content[-1000:]}")
            else:
                logger.info(f"‚úÖ Summary matches: {summary_matches}")

            for slide_num_str, placeholder_text in summary_matches:
                slide_num = int(slide_num_str)
                placeholders = []
                placeholder_counts = {}

                # Parse placeholder counts t·ª´ text nh∆∞ "1xLessonName, 2xTitleContent"
                for item in placeholder_text.split(','):
                    item = item.strip()
                    if 'x' in item:
                        # Format: "2xTitleName"
                        count_str, placeholder_type = item.split('x', 1)
                        try:
                            count = int(count_str)
                            placeholders.append(placeholder_type.strip())
                            placeholder_counts[placeholder_type.strip()] = count
                        except ValueError:
                            # Fallback n·∫øu kh√¥ng parse ƒë∆∞·ª£c s·ªë
                            placeholders.append(item)
                            placeholder_counts[item] = 1
                    else:
                        # Format c≈©: "TitleName"
                        placeholders.append(item)
                        placeholder_counts[item] = 1

                slide_summaries.append({
                    "slide_number": slide_num,
                    "placeholders": placeholders,
                    "placeholder_counts": placeholder_counts
                })

            # Log parsed results
            logger.info(f"üìã Parsed {len(slide_summaries)} slide summaries")
            for placeholder_type, items in parsed_data.items():
                if items:
                    logger.info(f"üìã {placeholder_type}: {len(items)} items")

            # Store slide summaries for mapping logic
            parsed_data["_slide_summaries"] = slide_summaries

            return parsed_data

        except Exception as e:
            logger.error(f"‚ùå Error parsing LLM content: {e}")
            raise

    async def _handle_max_length_content(
        self,
        content: str,
        max_length: int,
        placeholder_type: str,
        max_retries: int = 3
    ) -> str:
        """X·ª≠ l√Ω content v∆∞·ª£t qu√° max_length"""
        try:
            if len(content) <= max_length:
                return content

            logger.info(f"‚ö†Ô∏è Content too long for {placeholder_type}: {len(content)} > {max_length}")

            # Retry v·ªõi LLM ƒë·ªÉ r√∫t g·ªçn
            for attempt in range(max_retries):
                logger.info(f"üîÑ Retry {attempt + 1}/{max_retries} to shorten content...")

                shorten_prompt = f"""H√£y r√∫t g·ªçn n·ªôi dung sau ƒë·ªÉ kh√¥ng v∆∞·ª£t qu√° {max_length} k√Ω t·ª±, gi·ªØ nguy√™n √Ω nghƒ©a ch√≠nh:

ORIGINAL CONTENT:
{content}

REQUIREMENTS:
- T·ªëi ƒëa {max_length} k√Ω t·ª±
- Gi·ªØ nguy√™n √Ω nghƒ©a ch√≠nh
- Ph√π h·ª£p v·ªõi {placeholder_type}

SHORTENED CONTENT:"""

                llm_response = await self.llm_service.generate_content(
                    prompt=shorten_prompt,
                    max_tokens=5000,
                    temperature=0.1
                )

                if llm_response.get("success", False):
                    shortened_content = llm_response.get("text", "").strip()
                    if len(shortened_content) <= max_length:
                        logger.info(f"‚úÖ Content shortened: {len(shortened_content)} chars")
                        return shortened_content

            # Kh√¥ng s·ª≠ d·ª•ng fallback truncation
            logger.error(f"‚ùå Failed to shorten content for {placeholder_type} after {max_retries} retries")
            return content  # Tr·∫£ v·ªÅ content g·ªëc, ƒë·ªÉ frontend x·ª≠ l√Ω

        except Exception as e:
            logger.error(f"‚ùå Error handling max_length content: {e}")
            return content  # Tr·∫£ v·ªÅ content g·ªëc, kh√¥ng truncate

    def _find_exact_matching_template(
        self,
        required_placeholders: List[str],
        required_counts: Dict[str, int],
        template_slides: List[Dict[str, Any]],
        used_slide_ids: set
    ) -> Optional[Dict[str, Any]]:
        """
        T√¨m template slide match ch√≠nh x√°c v·ªõi required placeholders v√† counts
        (T∆∞∆°ng t·ª± logic trong lu·ªìng c≈©, kh√¥ng fallback)

        Args:
            required_placeholders: List placeholder types c·∫ßn thi·∫øt
            required_counts: Dict s·ªë l∆∞·ª£ng t·ª´ng placeholder type
            template_slides: List c√°c template slides
            used_slide_ids: Set c√°c slide IDs ƒë√£ s·ª≠ d·ª•ng

        Returns:
            Dict slide template match ch√≠nh x√°c ho·∫∑c None
        """
        try:
            for slide in template_slides:
                slide_id = slide.get("slideId")

                # Skip used slides
                if slide_id in used_slide_ids:
                    continue

                # Get placeholder types and counts in this slide
                slide_elements = slide.get("elements", [])
                slide_placeholder_counts = {}

                for elem in slide_elements:
                    placeholder_type = elem.get("Type")
                    if placeholder_type:
                        if placeholder_type in slide_placeholder_counts:
                            slide_placeholder_counts[placeholder_type] += 1
                        else:
                            slide_placeholder_counts[placeholder_type] = 1

                # Check for EXACT match: same placeholder types and same counts
                required_set = set(required_placeholders)
                slide_set = set(slide_placeholder_counts.keys())

                if required_set == slide_set:
                    # Check if counts also match exactly
                    counts_match = True
                    for placeholder_type, required_count in required_counts.items():
                        slide_count = slide_placeholder_counts.get(placeholder_type, 0)
                        if slide_count != required_count:
                            counts_match = False
                            break

                    if counts_match:
                        logger.info(f"‚úÖ Found EXACT matching template: {slide_id}")
                        logger.info(f"   Required: {required_counts}")
                        logger.info(f"   Template has: {slide_placeholder_counts}")
                        return slide
                    else:
                        logger.debug(f"‚ùå Template {slide_id}: placeholder types match but counts differ")
                        logger.debug(f"   Required: {required_counts}")
                        logger.debug(f"   Template has: {slide_placeholder_counts}")
                else:
                    logger.debug(f"‚ùå Template {slide_id}: placeholder types don't match")
                    logger.debug(f"   Required: {required_set}")
                    logger.debug(f"   Template has: {slide_set}")

            logger.info(f"‚ùå No EXACT matching template found for: {required_counts}")
            return None

        except Exception as e:
            logger.error(f"Error finding exact matching template: {e}")
            return None

    def _find_exact_matching_template_with_reuse(
        self,
        required_placeholders: List[str],
        required_counts: Dict[str, int],
        template_slides: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        """
        T√¨m template slide match ch√≠nh x√°c v·ªõi required placeholders (cho ph√©p reuse)
        (T∆∞∆°ng t·ª± logic trong lu·ªìng c≈©)

        Args:
            required_placeholders: List placeholder types c·∫ßn thi·∫øt
            required_counts: Dict s·ªë l∆∞·ª£ng t·ª´ng placeholder type
            template_slides: List c√°c template slides

        Returns:
            Dict slide template match ch√≠nh x√°c ho·∫∑c None
        """
        try:
            logger.info(f"üîç Finding exact matching template with reuse support...")

            for slide in template_slides:
                slide_id = slide.get("slideId")

                # Get placeholder types and counts in this slide
                slide_elements = slide.get("elements", [])
                slide_placeholder_counts = {}

                for elem in slide_elements:
                    placeholder_type = elem.get("Type")
                    if placeholder_type:
                        if placeholder_type in slide_placeholder_counts:
                            slide_placeholder_counts[placeholder_type] += 1
                        else:
                            slide_placeholder_counts[placeholder_type] = 1

                # Check for EXACT match: same placeholder types and same counts
                required_set = set(required_placeholders)
                slide_set = set(slide_placeholder_counts.keys())

                if required_set == slide_set:
                    # Check if counts also match exactly
                    counts_match = True
                    for placeholder_type, required_count in required_counts.items():
                        slide_count = slide_placeholder_counts.get(placeholder_type, 0)
                        if slide_count != required_count:
                            counts_match = False
                            break

                    if counts_match:
                        logger.info(f"‚úÖ Found EXACT matching template (reuse allowed): {slide_id}")
                        logger.info(f"   Required: {required_counts}")
                        logger.info(f"   Template has: {slide_placeholder_counts}")
                        return slide
                    else:
                        logger.debug(f"‚ùå Template {slide_id}: placeholder types match but counts differ")
                        logger.debug(f"   Required: {required_counts}")
                        logger.debug(f"   Template has: {slide_placeholder_counts}")
                else:
                    logger.debug(f"‚ùå Template {slide_id}: placeholder types don't match")
                    logger.debug(f"   Required: {required_set}")
                    logger.debug(f"   Template has: {slide_set}")

            logger.info(f"‚ùå No EXACT matching template found for reuse: {required_counts}")
            return None

        except Exception as e:
            logger.error(f"Error finding exact matching template with reuse: {e}")
            return None

    async def _create_processed_slide_from_template(
        self,
        template_slide: Dict[str, Any],
        parsed_data: Dict[str, List[Dict[str, Any]]],
        content_index: Dict[str, int],
        slide_number: int,
        is_reused: bool = False
    ) -> Optional[Dict[str, Any]]:
        """
        T·∫°o processed slide t·ª´ template slide v·ªõi content mapping
        (T∆∞∆°ng t·ª± logic trong lu·ªìng c≈©, kh√¥ng fallback)

        Args:
            template_slide: Template slide ƒë·ªÉ copy
            parsed_data: Parsed content t·ª´ LLM
            content_index: Index tracking cho content usage
            slide_number: S·ªë th·ª© t·ª± slide

        Returns:
            Dict processed slide ho·∫∑c None n·∫øu fail
        """
        try:
            template_slide_id = template_slide.get("slideId")
            template_elements = template_slide.get("elements", [])
            original_slide = template_slide.get("original_slide", {})

            # T·∫°o slideId m·ªõi cho processed slide
            if is_reused:
                new_slide_id = f"slide_{slide_number:03d}_reused_from_{template_slide_id}"
                logger.info(f"üìÑ Creating processed slide (REUSED): {new_slide_id} (from template: {template_slide_id})")
            else:
                new_slide_id = f"slide_{slide_number:03d}_from_{template_slide_id}"
                logger.info(f"üìÑ Creating processed slide (NEW): {new_slide_id} (from template: {template_slide_id})")

            # Copy to√†n b·ªô slide structure t·ª´ template (gi·ªëng lu·ªìng c≈© copy slide)
            processed_slide = copy.deepcopy(original_slide)

            # Ch·ªâ update nh·ªØng field c·∫ßn thi·∫øt
            processed_slide["id"] = new_slide_id  # Update slide ID
            processed_slide["elements"] = []  # Reset elements ƒë·ªÉ fill content m·ªõi

            # Map content v√†o t·ª´ng element
            for element in template_elements:
                element_id = element.get("objectId")
                placeholder_type = element.get("Type")
                max_length = element.get("max_length", 1000)
                original_element = element.get("original_element", {})

                # Get content for this placeholder type
                content_list = parsed_data.get(placeholder_type, [])
                current_index = content_index.get(placeholder_type, 0)

                logger.info(f"üîç Mapping content for {placeholder_type}:")
                logger.info(f"   Available content items: {len(content_list)}")
                logger.info(f"   Current index: {current_index}")
                logger.info(f"   Element ID: {element_id}")

                if current_index < len(content_list):
                    content_item = content_list[current_index]
                    raw_content = content_item.get("content", "")
                    logger.info(f"   Raw content: {raw_content}...")

                    try:
                        # Check max_length and handle if needed
                        final_content = await self._handle_max_length_content(
                            raw_content,
                            max_length,
                            placeholder_type
                        )

                        # Copy to√†n b·ªô JSON structure t·ª´ template (gi·ªëng lu·ªìng c≈© copy slide)
                        processed_element = copy.deepcopy(original_element)  # Deep copy to√†n b·ªô structure

                        # Ch·ªâ update nh·ªØng field c·∫ßn thi·∫øt
                        processed_element["id"] = element_id  # Update ID
                        processed_element["text"] = final_content  # Update content

                        processed_slide["elements"].append(processed_element)

                        # Increment content index
                        content_index[placeholder_type] = current_index + 1

                        logger.info(f"‚úÖ Mapped {placeholder_type} to {element_id}: {final_content}...")
                        logger.info(f"   Final content length: {len(final_content)}")
                        logger.info(f"   Element structure: {list(processed_element.keys())}")
                    except Exception as e:
                        logger.error(f"‚ùå Failed to handle content for {placeholder_type} in slide {slide_number}: {e}")
                        logger.error(f"   Content length: {len(raw_content)}, Max length: {max_length}")
                        logger.error(f"   SKIPPING this slide due to content length issue - NO FALLBACK")
                        return None  # Skip entire slide if any content fails
                else:
                    logger.warning(f"‚ùå No more content available for {placeholder_type} in slide {slide_number}")
                    logger.warning(f"   Available content items: {len(content_list)}")
                    logger.warning(f"   Current index: {current_index}")
                    logger.warning(f"   Content list: {[item.get('content', '') for item in content_list]}")
                    return None  # Skip slide if missing content

            logger.info(f"‚úÖ Successfully created processed slide {slide_number} with {len(processed_slide['elements'])} elements")
            return processed_slide

        except Exception as e:
            logger.error(f"‚ùå Error creating processed slide from template: {e}")
            return None




# Singleton instance
_json_template_service = None

def get_json_template_service() -> JsonTemplateService:
    """Get singleton instance c·ªßa JsonTemplateService"""
    global _json_template_service
    if _json_template_service is None:
        _json_template_service = JsonTemplateService()
    return _json_template_service
